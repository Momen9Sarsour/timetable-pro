app\Http\Controllers\DataEntry\CrossoverTypeController.php
<?php

namespace App\Http\Controllers\DataEntry;

use App\Http\Controllers\Controller;
use App\Models\CrossoverType;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Validation\Rule;
use Illuminate\Support\Facades\Log;

class CrossoverTypeController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        try {
            $crossoverTypes = CrossoverType::latest('crossover_id')->paginate(15);
            return view('dashboard.algorithm.crossover-types', compact('crossoverTypes'));
        } catch (Exception $e) {
            Log::error("Error fetching Crossover Types: " . $e->getMessage());
            return redirect()->back()->with('error', 'Could not load Crossover Methods page.');
        }
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        $validatedData = $request->validate([
            'name' => 'required|string|max:100|unique:crossover_types,name',
            'description' => 'nullable|string|max:500',
            'is_active' => 'sometimes|boolean',
        ]);

        try {
            $dataToCreate = $validatedData;
            $dataToCreate['is_active'] = $request->has('is_active');
            CrossoverType::create($dataToCreate);
            return redirect()->route('algorithm-control.crossover-types.index')->with('success', 'Crossover method created successfully.');
        } catch (Exception $e) {
            Log::error("Crossover Type Creation Failed: " . $e->getMessage());
            return redirect()->back()->with('error', 'Failed to create crossover method.')->withInput();
        }
    }

    /**
     * Display the specified resource.
     */
    public function show(CrossoverType $crossoverType)
    {
        //
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(CrossoverType $crossoverType)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, CrossoverType $crossoverType)
    {
        $errorBagName = 'editCrossoverModal_' . $crossoverType->crossover_id;
        $validatedData = $request->validate([
            'name' => ['required', 'string', 'max:100', Rule::unique('crossover_types')->ignore($crossoverType->crossover_id, 'crossover_id')],
            'description' => 'nullable|string|max:500',
            'is_active' => 'sometimes|boolean',
        ]);

        try {
            $dataToUpdate = $validatedData;
            $dataToUpdate['is_active'] = $request->has('is_active');
            $crossoverType->update($dataToUpdate);
            return redirect()->route('algorithm-control.crossover-types.index')->with('success', 'Crossover method updated successfully.');
        } catch (Exception $e) {
            Log::error("Crossover Type Update Failed for ID {$crossoverType->crossover_id}: " . $e->getMessage());
            return redirect()->back()->withErrors(['update_error' => 'Failed to update crossover method.'], $errorBagName)->withInput();
        }
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(CrossoverType $crossoverType)
    {
        try {
            // (اختياري) التحقق إذا كانت الطريقة مستخدمة في أي عملية تشغيل سابقة
            // if ($crossoverType->populations()->exists()) {
            //     return redirect()->route('algorithm-control.crossover-types.index')->with('error', 'Cannot delete: This method is used in historical data.');
            // }
            $crossoverType->delete();
            return redirect()->route('algorithm-control.crossover-types.index')->with('success', 'Crossover method deleted successfully.');
        } catch (Exception $e) {
            Log::error("Crossover Type Deletion Failed for ID {$crossoverType->crossover_id}: " . $e->getMessage());
            return redirect()->route('algorithm-control.crossover-types.index')->with('error', 'Failed to delete crossover method.');
        }
    }
}
-------------------------------------------------------------------------------------------------------
app\Http\Controllers\DataEntry\SelectionTypeController.php
<?php

namespace App\Http\Controllers\DataEntry;

use App\Http\Controllers\Controller;
use App\Models\SelectionType;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Validation\Rule;

class SelectionTypeController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index()
    {
        try {
            $selectionTypes = SelectionType::latest('selection_type_id')->paginate(15);
            return view('dashboard.algorithm.selection-types', compact('selectionTypes'));
        } catch (Exception $e) {
            Log::error("Error fetching Selection Types: " . $e->getMessage());
            return redirect()->back()->with('error', 'Could not load Selection Methods page.');
        }
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create()
    {
        //
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(Request $request)
    {
        $validatedData = $request->validate([
            'name' => 'required|string|max:100|unique:selection_types,name',
            'description' => 'nullable|string|max:500',
            'is_active' => 'sometimes|boolean',
        ]);

        try {
            $dataToCreate = $validatedData;
            $dataToCreate['is_active'] = $request->has('is_active');
            SelectionType::create($dataToCreate);
            return redirect()->route('algorithm-control.selection-types.index')->with('success', 'Selection method created successfully.');
        } catch (Exception $e) {
            Log::error("Selection Type Creation Failed: " . $e->getMessage());
            return redirect()->back()->with('error', 'Failed to create selection method.')->withInput();
        }
    }

    /**
     * Display the specified resource.
     */
    public function show(SelectionType $selectionType)
    {
        //
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(SelectionType $selectionType)
    {
        //
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(Request $request, SelectionType $selectionType)
    {
        // لاحظ أن اسم المتغير هو $selectionType كما يولده Laravel
        $errorBagName = 'editSelectionModal_' . $selectionType->selection_type_id;
        $validatedData = $request->validate([
            'name' => ['required', 'string', 'max:100', Rule::unique('selection_types')->ignore($selectionType->selection_type_id, 'selection_type_id')],
            'description' => 'nullable|string|max:500',
            'is_active' => 'sometimes|boolean',
        ]);

        try {
            $dataToUpdate = $validatedData;
            $dataToUpdate['is_active'] = $request->has('is_active');
            $selectionType->update($dataToUpdate);
            return redirect()->route('algorithm-control.selection-types.index')->with('success', 'Selection method updated successfully.');
        } catch (Exception $e) {
            Log::error("Selection Type Update Failed for ID {$selectionType->selection_type_id}: " . $e->getMessage());
            return redirect()->back()->withErrors(['update_error' => 'Failed to update selection method.'], $errorBagName)->withInput();
        }
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(SelectionType $selectionType)
    {
        try {
            // (اختياري) التحقق إذا كانت الطريقة مستخدمة
            // if ($selectionType->populations()->exists()) {
            //     return redirect()->route('algorithm-control.selection-types.index')->with('error', 'Cannot delete: This method is used in historical data.');
            // }
            $selectionType->delete();
            return redirect()->route('algorithm-control.selection-types.index')->with('success', 'Selection method deleted successfully.');
        } catch (Exception $e) {
            Log::error("Selection Type Deletion Failed for ID {$selectionType->selection_type_id}: " . $e->getMessage());
            return redirect()->route('algorithm-control.selection-types.index')->with('error', 'Failed to delete selection method.');
        }
    }
}
---------------------------------------------------------------------------------------------------------
app\Http\Controllers\Algorithm\TimetableGenerationController.php
<?php

namespace App\Http\Controllers\Algorithm;

use App\Http\Controllers\Controller;
use App\Jobs\GenerateTimetableJob;
use App\Models\Chromosome;
use Illuminate\Http\Request;
use App\Models\Population; // موديل POPULATIONS
use App\Models\Crossover;
use App\Models\SelectionType;
use App\Models\Timeslot;
use App\Services\ConflictCheckerService;
use App\Services\GeneticAlgorithmService; // الـ Service الذي أنشأناه
use Exception;
use Illuminate\Support\Facades\Log;
use Illuminate\Validation\Rule;

class TimetableGenerationController extends Controller
{
    /**
     * Start the timetable generation process.
     * تبدأ عملية توليد الجدول بناءً على الإعدادات من المودال
     */
    // public function start(Request $request)
    // {
    //     // 1. التحقق من صحة الإعدادات القادمة من المودال
    //     $validatedSettings = $request->validate([
    //         'population_size' => 'required|integer|min:10|max:500',
    //         'max_generations' => 'required|integer|min:10|max:10000',
    //         'mutation_rate' => 'required|numeric|min:0|max:1',
    //         'crossover_type_id' => ['required', 'integer', Rule::exists('crossover_types', 'crossover_id')->where('is_active', true)],
    //         'selection_type_id' => ['required', 'integer', Rule::exists('selection_types', 'selection_type_id')->where('is_active', true)],
    //         'stop_at_first_valid' => 'nullable|boolean',
    //     ]);
    //     // dd([
    //     //     '$request->all()' => $request->all(),
    //     //     'validatedSettings' => $validatedSettings,
    //     // ]);

    //     try {
    //         // 2. إنشاء سجل جديد لعملية التشغيل في جدول POPULATIONS
    //         $populationRun = Population::create([
    //             'population_size' => $validatedSettings['population_size'],
    //             'crossover_id' => $validatedSettings['crossover_type_id'],
    //             'selection_id' => $validatedSettings['selection_type_id'],
    //             'mutation_rate' => $validatedSettings['mutation_rate'],
    //             'generations_count' => $validatedSettings['max_generations'], // يمكن استخدام هذا كحد أقصى
    //             'status' => 'running', // تبدأ كـ "قيد الانتظار"
    //         ]);

    //         Log::info("New Population Run created with ID: {$populationRun->population_id}. Starting GA Service.");

    //         // 3. إنشاء وتشغيل الـ Service
    //         // **ملاحظة هامة:** الآن سنقوم بتشغيلها مباشرة. في التطبيق الحقيقي،
    //         // يجب تحويل هذا إلى Job يعمل في الخلفية لتجنب تجميد المتصفح.
    //         // dispatch(new GenerateTimetableJob($validatedSettings, $populationRun));
    //         // $gaService = new GeneticAlgorithmService($validatedSettings, $populationRun);
    //         // $gaService->run(); // بدء التنفيذ

    //         // 3. *** إرسال المهمة (Job) إلى الطابور ***
    //         GenerateTimetableJob::dispatch($validatedSettings, $populationRun);

    //         // 4. إعادة التوجيه مع رسالة نجاح
    //         return redirect()->route('dashboard.index') // أو صفحة عرض حالة الخوارزمية
    //             ->with('success', 'Timetable generation process has started successfully! Population Run ID: ' . $populationRun->population_id);
    //     } catch (\Exception $e) {
    //         Log::error('Failed to start timetable generation process: ' . $e->getMessage());
    //         return redirect()->back()
    //             ->with('error', 'Could not start the generation process. Error: ' . $e->getMessage())
    //             ->withInput();
    //     }
    // }

    // public function start(Request $request)
    // {
    //     $validatedSettings = $request->validate([
    //         'population_size' => 'required|integer|min:10|max:500',
    //         'max_generations' => 'required|integer|min:10|max:10000',
    //         'mutation_rate' => 'required|numeric|min:0|max:1',
    //         'crossover_type_id' => ['required', 'integer', Rule::exists('crossover_types', 'crossover_id')->where('is_active', true)],
    //         'selection_type_id' => ['required', 'integer', Rule::exists('selection_types', 'selection_type_id')->where('is_active', true)],
    //         'stop_at_first_valid' => 'nullable|boolean',
    //     ]);

    //     try {
    //         // إنشاء سجل عملية التشغيل
    //         $populationRun = Population::create([
    //             'population_size' => $validatedSettings['population_size'],
    //             'crossover_id' => $validatedSettings['crossover_type_id'],
    //             'selection_id' => $validatedSettings['selection_type_id'],
    //             'mutation_rate' => $validatedSettings['mutation_rate'],
    //             'generations_count' => $validatedSettings['max_generations'],
    //             'status' => 'running',
    //         ]);

    //         Log::info("New Population Run created with ID: {$populationRun->population_id}. Dispatching job to queue.");

    //         // إرسال المهمة (Job) إلى الطابور
    //         GenerateTimetableJob::dispatch($validatedSettings, $populationRun);

    //         return redirect()->route('dashboard.index')
    //             ->with('success', 'The timetable generation process has been started in the background. Run ID: ' . $populationRun->population_id);
    //     } catch (\Exception $e) {
    //         Log::error('Failed to dispatch timetable generation job: ' . $e->getMessage());
    //         return redirect()->back()
    //             ->with('error', 'Could not start the generation process: ' . $e->getMessage())
    //             ->withInput();
    //     }
    // }
    public function start(Request $request)
    {
        $validatedSettings = $request->validate([
            'academic_year' => 'required|integer|digits:4',
            'semester' => 'required|integer|in:1,2,3',
            'population_size' => 'required|integer|min:10|max:500',
            'max_generations' => 'required|integer|min:10|max:10000',
            'mutation_rate' => 'required|numeric|min:0|max:1',
            'crossover_type_id' => ['required', 'integer', Rule::exists('crossover_types', 'crossover_id')->where('is_active', true)],
            'selection_type_id' => ['required', 'integer', Rule::exists('selection_types', 'selection_type_id')->where('is_active', true)],
            'stop_at_first_valid' => 'nullable|boolean',
        ]);
        // تحويل boolean
        $validatedSettings['stop_at_first_valid'] = $request->has('stop_at_first_valid');

        try {
            $populationRun = Population::create([
                'population_size' => $validatedSettings['population_size'],
                'crossover_id' => $validatedSettings['crossover_type_id'],
                'selection_id' => $validatedSettings['selection_type_id'],
                'mutation_rate' => $validatedSettings['mutation_rate'],
                'generations_count' => $validatedSettings['max_generations'],
                'status' => 'running',
            ]);

            Log::info("New Population Run created with ID: {$populationRun->population_id}. Dispatching job to queue.");

            // $gaService = new GeneticAlgorithmService($validatedSettings, $populationRun);
            // $gaService->run(); // بدء التنفيذ

            GenerateTimetableJob::dispatch($validatedSettings, $populationRun);

            return redirect()->route('dashboard.index')
                ->with('success', "Timetable generation started for Year: {$validatedSettings['academic_year']}, Semester: {$validatedSettings['semester']}. Run ID: " . $populationRun->population_id);
            // return redirect()->route('dashboard.index')
            //     ->with('success', 'The timetable generation process has been started in the background. Run ID: ' . $populationRun->population_id);
        } catch (Exception $e) {
            Log::error('Failed to dispatch timetable generation job: ' . $e->getMessage());
            return redirect()->back()
                ->with('error', 'Could not start the generation process: ' . $e->getMessage())
                ->withInput();
        }
    }



    // public function show(Population $population)
    // {
    //     try {
    //         // جلب أفضل كروموسوم (جدول) لهذه العملية
    //         // إذا كان best_chromosome_id مسجلاً، استخدمه. وإلا، ابحث عن الأفضل.
    //         if ($population->best_chromosome_id) {
    //             $bestChromosome = Chromosome::find($population->best_chromosome_id);
    //         } else {
    //             $bestChromosome = $population->chromosomes()->orderBy('penalty_value', 'asc')->first();
    //         }

    //         if (!$bestChromosome) {
    //             return redirect()->route('dashboard.index')->with('error', 'No valid schedule found for this generation run yet.');
    //         }

    //         // جلب كل الجينات (المحاضرات) مع كل تفاصيلها اللازمة للعرض
    //         $genes = $bestChromosome->genes()->with([
    //             'section.planSubject.subject',
    //             'instructor.user',
    //             'room',
    //             'timeslot'
    //         ])->get();

    //         // *** استخدام Service جديد لفحص التعارضات وتحديدها ***
    //         $conflictChecker = new ConflictCheckerService($genes);
    //         $conflicts = $conflictChecker->getConflicts(); // مصفوفة بتفاصيل التعارضات
    //         $conflictingGeneIds = $conflictChecker->getConflictingGeneIds(); // مصفوفة بـ IDs الجينات المتعارضة

    //         // جلب كل الفترات الزمنية المتاحة لعرض الجدول بشكل صحيح
    //         $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');

    //         // تحضير بيانات الجدول للعرض
    //         $scheduleData = [];
    //         foreach ($genes as $gene) {
    //             $scheduleData[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene;
    //         }

    //         return view('dashboard.timetable-result.show', compact(
    //             'population',
    //             'bestChromosome',
    //             'scheduleData',
    //             'timeslots',
    //             'conflicts',
    //             'conflictingGeneIds'
    //         ));
    //     } catch (Exception $e) {
    //         Log::error("Error showing timetable result: " . $e->getMessage());
    //         return redirect()->route('dashboard.index')->with('error', 'Could not display the schedule result.');
    //     }
    // }
}
--------------------------------------------------------------------------------------------------------
app\Jobs\GenerateTimetableJob.php
<?php

namespace App\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use App\Models\Population; // استيراد الموديل
use App\Services\GeneticAlgorithmService; // استيراد الـ Service
use Illuminate\Support\Facades\Log;
use Throwable; // لالتقاط كل الأخطاء

class GenerateTimetableJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    // خصائص لتخزين الإعدادات ومعلومات التشغيل
    protected array $settings;
    protected Population $populationRun;

    /**
     * Create a new job instance.
     */
    public function __construct(array $settings, Population $populationRun)
    {
        $this->settings = $settings;
        $this->populationRun = $populationRun;
    }

    /**
     * Execute the job.
     * هذه الدالة هي التي سيقوم الـ Queue Worker بتنفيذها في الخلفية
     */
    public function handle(): void
    {
        Log::info("Job starting for Population Run ID: {$this->populationRun->population_id}");
        try {
            // إنشاء وتشغيل الـ Service
            $gaService = new GeneticAlgorithmService($this->settings, $this->populationRun);
            $gaService->run(); // بدء التنفيذ الفعلي للخوارزمية

        } catch (Throwable $e) {
            // إذا حدث أي خطأ فادح أثناء عمل الـ Job
            Log::error("GenerateTimetableJob failed for Population Run ID: {$this->populationRun->population_id}. Error: " . $e->getMessage());
            // تحديث حالة التشغيل إلى "failed"
            $this->populationRun->update(['status' => 'failed']);
            // يمكنك إرسال إشعار للمستخدم بأن العملية فشلت
             // $this->fail($e); // هذا يضع المهمة في جدول failed_jobs
        }
    }
}
--------------------------------------------------------------------------------------------------------
app\Services\GeneticAlgorithmService.php
<?php

namespace App\Services;

use App\Models\Population;
use App\Models\Chromosome;
use App\Models\Gene;
use App\Models\Section;
use App\Models\Instructor;
use App\Models\Room;
use App\Models\Timeslot;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use Exception;

class GeneticAlgorithmService
{
    // الخصائص لتخزين البيانات والإعدادات
    private array $settings;
    private Population $populationRun;
    private Collection $sectionsToSchedule;
    private Collection $instructors;
    private Collection $rooms;
    private Collection $timeslots;
    private Collection $theoryRooms; // **جديد: قاعات نظرية مفلترة**
    private Collection $practicalRooms; // **جديد: قاعات عملية مفلترة**

    /**
     * تهيئة الـ Service
     */
    public function __construct(array $settings, Population $populationRun)
    {
        $this->settings = $settings;
        $this->populationRun = $populationRun;
        Log::info("GA Service initialized for Run ID: {$this->populationRun->population_id}");
    }

    /**
     * الدالة الرئيسية لتشغيل الخوارزمية
     */
    public function run()
    {
        try {
            $this->populationRun->update(['status' => 'running', 'start_time' => now()]);
            // 1. تحميل كل البيانات اللازمة
            $this->loadDataForContext();

            // 2. إنشاء الجيل الأول وتقييمه
            $currentGenerationNumber = 1;
            $currentPopulation = $this->createInitialPopulation($currentGenerationNumber);
            $this->evaluateFitness($currentPopulation);
            Log::info("Generation #{$currentGenerationNumber} fitness evaluated.");

            // 3. حلقة تطور الأجيال
            $maxGenerations = $this->settings['max_generations'];
            while ($currentGenerationNumber < $maxGenerations) {
                // التحقق من شرط التوقف
                $bestInGen = $currentPopulation->sortBy('penalty_value')->first();
                if ($bestInGen && $bestInGen->penalty_value == 0 && ($this->settings['stop_at_first_valid'] ?? false)) {
                    Log::info("Optimal solution found in Generation #{$currentGenerationNumber}. Stopping.");
                    break;
                }

                // اختيار الآباء
                $parents = $this->selectParents($currentPopulation);

                // إنشاء الجيل الجديد
                $currentGenerationNumber++;
                $currentPopulation = $this->createNewGeneration($parents, $currentGenerationNumber);

                // تقييم الجيل الجديد
                $this->evaluateFitness($currentPopulation);
                Log::info("Generation #{$currentGenerationNumber} fitness evaluated.");
            }

            // 4. تحديث النتيجة النهائية
            $finalBest = Chromosome::where('population_id', $this->populationRun->population_id)->orderBy('penalty_value', 'asc')->first();
            $this->populationRun->update([
                'status' => 'completed',
                'end_time' => now(),
                'best_chromosome_id' => $finalBest ? $finalBest->chromosome_id : null
            ]);
            // dd([
            //     'currentPopulation' => $currentPopulation,
            //     'bestInGen' => $bestInGen,
            //     'finalBest' => $finalBest,
            //     '$finalBest->chromosome_id' => $finalBest->chromosome_id,
            // ]);
            Log::info("GA Run ID: {$this->populationRun->population_id} completed.");
        } catch (Exception $e) {
            Log::error("GA Run failed: " . $e->getMessage() . " at " . $e->getFile() . ":" . $e->getLine());
            $this->populationRun->update(['status' => 'failed']);
            throw $e; // Throw exception to fail the job
        }
    }

    /**
     * تحميل البيانات المفلترة بناءً على السياق (سنة وفصل)
     */
    // private function loadDataForContext()
    // {
    //     Log::info("Loading data for context -> Year: {$this->settings['academic_year']}, Semester: {$this->settings['semester']}");

    //     // جلب الشعب المحددة للسياق
    //     $this->sectionsToSchedule = Section::where('academic_year', $this->settings['academic_year'])
    //         ->where('semester', $this->settings['semester'])->get();
    //     if ($this->sectionsToSchedule->isEmpty()) {
    //         throw new Exception("No sections found for the selected context (Year: {$this->settings['academic_year']}, Semester: {$this->settings['semester']}).");
    //     }

    //     // جلب كل الموارد الأخرى المتاحة
    //     $this->instructors = Instructor::all();
    //     $this->rooms = Room::all();
    //     $this->timeslots = Timeslot::all(); // *** نعبئ this->timeslots هنا ***

    //     if ($this->instructors->isEmpty() || $this->rooms->isEmpty() || $this->timeslots->isEmpty()) {
    //         throw new Exception("Missing essential data (instructors, rooms, or timeslots).");
    //     }
    //     Log::info("Data loaded: " . $this->sectionsToSchedule->count() . " sections to be scheduled.");
    // }

    private function loadDataForContext()
    {
        Log::info("Loading data for context -> Year: {$this->settings['academic_year']}, Semester: {$this->settings['semester']}");

        // جلب الشعب وتحميل العلاقات اللازمة لتحديد المدرسين والقاعات
        $this->sectionsToSchedule = Section::with('planSubject.subject.instructors') // *** تحميل المدرسين المرتبطين بالمادة ***
            ->where('academic_year', $this->settings['academic_year'])
            ->where('semester', $this->settings['semester'])->get();

        if ($this->sectionsToSchedule->isEmpty()) {
            throw new Exception("No sections found for the selected context.");
        }

        // جلب كل المدرسين والقاعات والأوقات
        $this->instructors = Instructor::all(); // سنستخدمها كـ fallback
        $this->timeslots = Timeslot::all();
        // **تقسيم القاعات حسب النوع**
        $this->theoryRooms = Room::whereHas('roomType', fn($q) => $q->where('room_type_name', 'not like', '%Lab%')->where('room_type_name', 'not like', '%مختبر%'))->get();
        $this->practicalRooms = Room::whereHas('roomType', fn($q) => $q->where('room_type_name', 'like', '%Lab%')->orWhere('room_type_name', 'like', '%مختبر%'))->get();

        if ($this->instructors->isEmpty() || $this->theoryRooms->isEmpty() || $this->practicalRooms->isEmpty() || $this->timeslots->isEmpty()) {
            throw new Exception("Missing essential data (instructors, theory/practical rooms, or timeslots).");
        }
        Log::info("Data loaded: " . $this->sectionsToSchedule->count() . " sections to be scheduled.");
    }

    /**
     * إنشاء الجيل الأول من الجداول العشوائية
     */
    private function createInitialPopulation(int $generationNumber): Collection
    {
        Log::info("Creating initial population (Generation #{$generationNumber})");
        $newChromosomesData = [];
        // انشاء مجموعة جداول عشوائية Chromosomes
        for ($i = 0; $i < $this->settings['population_size']; $i++) {
            $newChromosomesData[] = [
                'population_id' => $this->populationRun->population_id,
                'penalty_value' => -1, // قيمة مبدئية
                'generation_number' => $generationNumber,
                'created_at' => now(),
                'updated_at' => now(),
            ];
        }
        Chromosome::insert($newChromosomesData); // إدخال كل الكروموسومات دفعة واحدة

        // جلب الكروموسومات التي تم إنشاؤها للتو للحصول على IDs
        $createdChromosomes = Chromosome::where('population_id', $this->populationRun->population_id)
        ->where('generation_number', $generationNumber)->get();

        $allGenesToInsert = [];
        foreach ($createdChromosomes as $chromosome) {
            foreach ($this->sectionsToSchedule as $section) {
                $instructor = $this->getRandomInstructorForSection($section);
                $room = $this->getRandomRoomForSection($section);
                $allGenesToInsert[] = [
                    'chromosome_id' => $chromosome->chromosome_id,
                    'section_id' => $section->id,
                    // 'instructor_id' => $this->instructors->random()->id,
                    'instructor_id' => $instructor->id,
                    // 'room_id' => $this->rooms->random()->id,
                    'room_id' => $room->id,
                    'timeslot_id' => $this->timeslots->random()->id, // *** استخدام الطريقة الصحيحة ***
                ];
            }
        }

        // إدخال كل الجينات لكل الكروموسومات دفعة واحدة (أكثر كفاءة)
        foreach (array_chunk($allGenesToInsert, 500) as $chunk) {
            Gene::insert($chunk);
        }


        // dd([
        //     'createdChromosomes' => $createdChromosomes,
        //     '$this->timeslots->random()->id' => $this->timeslots->random()->id,
        //     'allGenesToInsert' => $allGenesToInsert,
        //     'array_chunk($allGenesToInsert,500)' => array_chunk($allGenesToInsert,500),
        // ]);
        return $createdChromosomes;
    }

    private function getRandomInstructorForSection(Section $section)
    {
        // 1. جلب المدرسين المعينين للمادة من خلال جدول instructor_subject
        $suitableInstructors = optional(optional($section->planSubject)->subject)->instructors;

        // 2. إذا وجد مدرسون مناسبون للمادة، اختر واحداً منهم عشوائياً
        if ($suitableInstructors && $suitableInstructors->isNotEmpty()) {
            return $suitableInstructors->random();
        }

        // جلب المدرسين المعينين لهذه الشعبة المحددة من خلال instructor_section
        // if ($section->instructors->isNotEmpty()) {
        //     return $section->instructors->random();
        // }


        // 3. كحل بديل (Fallback) إذا لم يتم تعيين مدرسين للمادة، اختر أي مدرس عشوائي
        Log::warning("No specific instructors assigned to subject for section ID: {$section->id}. Choosing a random instructor.");
        return $this->instructors->random();
    }


    /**
     * دالة مساعدة لاختيار قاعة عشوائية ومناسبة للشعبة
     */
    private function getRandomRoomForSection(Section $section)
    {
        // 1. تحديد نوع النشاط للشعبة (نظري أو عملي)
        $activityType = $section->activity_type;

        // 2. إذا كان عملي، اختر من قاعات المختبرات
        if ($activityType === 'Practical' && $this->practicalRooms->isNotEmpty()) {
            // يمكنك إضافة منطق هنا لاختيار مختبر سعته مناسبة للشعبة
            $suitableRooms = $this->practicalRooms->where('room_size', '>=', $section->student_count);
            return $suitableRooms->isNotEmpty() ? $suitableRooms->random() : $this->practicalRooms->random(); // كحل بديل إذا لا توجد قاعة مناسبة
        }

        // 3. إذا كان نظري (أو كـ fallback)، اختر من القاعات النظرية
        if ($this->theoryRooms->isNotEmpty()) {
            $suitableRooms = $this->theoryRooms->where('room_size', '>=', $section->student_count);
            return $suitableRooms->isNotEmpty() ? $suitableRooms->random() : $this->theoryRooms->random();
        }

        // 4. حل بديل أخير إذا لم يتم العثور على أي نوع
        return Room::all()->random();
    }

    /**
     * تقييم جودة كل جدول في المجموعة
     */
    private function evaluateFitness(Collection $chromosomes)
    {
        Log::info("Evaluating fitness for " . $chromosomes->count() . " chromosomes...");
        // حساب العقوبات لكل جدول
        foreach ($chromosomes as $chromosome) {
            $genes = $chromosome->genes()->with(['instructor', 'room', 'timeslot', 'section.planSubject.subject'])->get();
            // $genes = $chromosome->genes()->with(['instructor', 'room', 'timeslot', 'section.planSubject.subject', 'section.activity_type'])->get();
            $totalPenalty = 0;
            $genesByTimeslot = $genes->groupBy('timeslot_id');

            // هنستخدم هذا المصفوفة لحساب الساعات اليومية
            $dailyHours = [];

            foreach ($genesByTimeslot as $genesInSlot) {
                if ($genesInSlot->count() > 1) {
                    $totalPenalty += ($genesInSlot->count() - $genesInSlot->pluck('instructor_id')->unique()->count()) * 1000;
                    $totalPenalty += ($genesInSlot->count() - $genesInSlot->pluck('room_id')->unique()->count()) * 1000;
                    $totalPenalty += ($genesInSlot->count() - $genesInSlot->pluck('section_id')->unique()->count()) * 1000;
                }

                // القيود على كل محاضرة في هذا الوقت
                foreach ($genesInSlot as $gene) {
                    $day = $gene->timeslot->day; // اليوم (مثلاً "Monday")

                    // نحسب الساعات اليومية
                    if (!isset($dailyHours[$day])) {
                        $dailyHours[$day] = 0;
                    }
                    $dailyHours[$day] += $gene->timeslot->duration_hours;

                    // سعة القاعة
                    if ($gene->section->students_count > $gene->room->capacity) {
                        $totalPenalty += 800 * ($gene->section->students_count - $gene->room->capacity);
                    }

                    // نوع القاعة
                    if ($gene->section->activity_type != $gene->room->room_type) {
                        $totalPenalty += 600;
                    }

                    // وقت المحاضرة (إجازة)
                    if ($gene->timeslot->is_holiday) {
                        $totalPenalty += 1500;
                    }

                    // أهلية المدرس
                    // if (!$gene->instructor->canTeach($gene->section->subject)) {
                    if (
                        $gene->instructor &&
                        $gene->section &&
                        $gene->section->planSubject &&
                        $gene->section->planSubject->subject &&
                        !$gene->instructor->canTeach($gene->section->planSubject->subject)
                    ) {
                        $totalPenalty += 2000;
                    }
                }
            }

            // القيود على الساعات اليومية
            foreach ($dailyHours as $day => $hours) {
                if ($hours > 10) { // إذا تجاوزت 10 ساعات في اليوم
                    $totalPenalty += 300;
                }
            }
            // ... (باقي حسابات الـ penalty للسعة والنوع) ...
            $chromosome->update(['penalty_value' => $totalPenalty]);
        }
        // dd([
        //     'chromosomes' => $chromosomes,
        //     'genes' => $chromosome->genes->all(),
        //     'genesByTimeslot' => $genesByTimeslot,
        // ]);

        Log::info("Fitness evaluation completed.");
    }

    /**
     * اختيار الآباء (Tournament Selection)
     */
    private function selectParents(Collection $population): array
    {
        $parents = [];
        $populationSize = $this->settings['population_size'];
        $tournamentSize = 3; // يمكن جعله إعداداً
        for ($i = 0; $i < $populationSize; $i++) {
            $parents[] = $population->random($tournamentSize)->sortBy('penalty_value')->first();
        }
        // dd([
        //     'population' => $population,
        //     'parents' => $parents,
        // ]);
        return $parents;
    }

    /**
     * إنشاء جيل جديد بالتزاوج والطفرة
     */
    private function createNewGeneration(array $parents, int $nextGenerationNumber): Collection
    {
        Log::info("Creating new generation #{$nextGenerationNumber}");
        $childrenChromosomesData = [];
        $populationSize = $this->settings['population_size'];
        $parentPool = $parents;

        for ($i = 0; $i < $populationSize; $i += 2) {
            if (count($parentPool) < 2) {
                $parentPool = $parents;
            }
            $p1_key = array_rand($parentPool);
            $parent1 = $parentPool[$p1_key];
            unset($parentPool[$p1_key]);
            $p2_key = array_rand($parentPool);
            $parent2 = $parentPool[$p2_key];
            unset($parentPool[$p2_key]);

            [$child1GenesData, $child2GenesData] = $this->performCrossover($parent1, $parent2);

            $childrenChromosomesData[] = $this->performMutation($child1GenesData);
            if (count($childrenChromosomesData) < $populationSize) {
                $childrenChromosomesData[] = $this->performMutation($child2GenesData);
            }
        }


        $newlyCreatedChromosomes = [];
        foreach ($childrenChromosomesData as $genesToInsert) {
            $newlyCreatedChromosomes[] = $this->saveChildChromosome($genesToInsert, $nextGenerationNumber);
        }
        // dd([
        //     'nextGenerationNumber' => $nextGenerationNumber,
        //     'parents' => $parents,
        //     'parentPool' => $parentPool,
        //     'child1GenesData' => $child1GenesData,
        //     'child2GenesData' => $child2GenesData,
        //     'childrenChromosomesData' => $childrenChromosomesData,
        //     'newlyCreatedChromosomes' => $newlyCreatedChromosomes,
        // ]);
        return collect($newlyCreatedChromosomes);
    }

    /**
     * تنفيذ التزاوج (Single-Point Crossover) - آمن
     */
    private function performCrossover(Chromosome $parent1, Chromosome $parent2): array
    {
        $p1Genes = $parent1->genes()->get()->keyBy('section_id');
        $p2Genes = $parent2->genes()->get()->keyBy('section_id');
        $child1GenesData = [];
        $child2GenesData = [];
        $crossoverPoint = rand(1, $this->sectionsToSchedule->count() - 1);
        $currentIndex = 0;

        foreach ($this->sectionsToSchedule as $section) {
            $sectionId = $section->id;
            $sourceForChild1 = ($currentIndex < $crossoverPoint) ? $p1Genes : $p2Genes;
            $sourceForChild2 = ($currentIndex < $crossoverPoint) ? $p2Genes : $p1Genes;
            $gene1 = $sourceForChild1->get($sectionId) ?? $p2Genes->get($sectionId);
            $gene2 = $sourceForChild2->get($sectionId) ?? $p1Genes->get($sectionId);

            $child1GenesData[] = $gene1 ? $this->extractGeneData($gene1) : $this->createRandomGeneData($sectionId);
            $child2GenesData[] = $gene2 ? $this->extractGeneData($gene2) : $this->createRandomGeneData($sectionId);
            $currentIndex++;
        }
        return [$child1GenesData, $child2GenesData];
    }

    /**
     * تنفيذ الطفرة
     */
    // private function performMutation(array $genes): array
    // {
    //     foreach ($genes as &$geneData) {
    //         if (lcg_value() < $this->settings['mutation_rate']) {
    //             $geneData['timeslot_id'] = $this->timeslots->random()->id; // ** استخدام الطريقة الصحيحة **
    //         }
    //     }
    //     return $genes;
    // }
    private function performMutation(array $genes): array
    {
        foreach ($genes as &$geneData) { // استخدام & لتمرير بالمرجع
            if (lcg_value() < $this->settings['mutation_rate']) {
                Log::info("Mutation on gene for section ID: {$geneData['section_id']}");
                // اختيار عشوائي لما سيتم تغييره (الطفرة)
                $mutationType = rand(1, 3);
                switch ($mutationType) {
                    case 1:
                        // تغيير الفترة الزمنية
                        $geneData['timeslot_id'] = $this->timeslots->random()->id;
                        break;
                    case 2:
                        // تغيير القاعة (مع مراعاة النوع)
                        $section = $this->sectionsToSchedule->find($geneData['section_id']);
                        if ($section) {
                            $geneData['room_id'] = $this->getRandomRoomForSection($section)->id;
                        }
                        break;
                    case 3:
                        // تغيير المدرس (مع مراعاة التخصص)
                        $section = $this->sectionsToSchedule->find($geneData['section_id']);
                        if ($section) {
                            $geneData['instructor_id'] = $this->getRandomInstructorForSection($section)->id;
                        }
                        break;
                }
            }
        }
        return $genes;
    }


    /**
     * دوال مساعدة
     */
    private function saveChildChromosome(array $genes, int $generationNumber): Chromosome
    {
        $chromosome = Chromosome::create(['population_id' => $this->populationRun->population_id, 'penalty_value' => -1, 'generation_number' => $generationNumber]);
        foreach ($genes as &$geneData) {
            $geneData['chromosome_id'] = $chromosome->chromosome_id;
        }
        Gene::insert($genes);
        return $chromosome;
    }
    private function extractGeneData($gene): array
    {
        return ['section_id' => $gene->section_id, 'instructor_id' => $gene->instructor_id, 'room_id' => $gene->room_id, 'timeslot_id' => $gene->timeslot_id];
    }

    private function createRandomGeneData(int $sectionId): array
    {
        $section = $this->sectionsToSchedule->find($sectionId);
        if (!$section) return []; // حالة نادرة

        $instructor = $this->getRandomInstructorForSection($section);
        $room = $this->getRandomRoomForSection($section);

        return [
            'section_id' => $sectionId,
            'instructor_id' => $instructor->id,
            'room_id' => $room->id,
            'timeslot_id' => $this->timeslots->random()->id,
        ];

        // return [
        //     'section_id' => $sectionId,
        //     'instructor_id' => $this->instructors->random()->id,
        //     'room_id' => $this->rooms->random()->id,
        //     'timeslot_id' => $this->timeslots->random()->id, // ** استخدام الطريقة الصحيحة **
        // ];
    }
}
--------------------------------------------------------------------------------------------------------
app\Http\Controllers\Algorithm\TimetableResultController.php
<?php

namespace App\Http\Controllers\Algorithm;

use App\Http\Controllers\Controller;
use App\Models\Population;
use App\Models\Chromosome;
use App\Models\Timeslot;
use App\Services\ConflictCheckerService;
use Illuminate\Http\Request;
use Exception;
use Illuminate\Support\Facades\Log;

class TimetableResultController extends Controller
{
    /**
     * Display a list of generation runs and top chromosomes for a selected run.
     */
    // public function index(Request $request)
    // {
    //     try {
    //         // جلب كل عمليات التشغيل (Populations) لعرضها في قائمة منسدلة
    //         $allRuns = Population::orderBy('start_time', 'desc')->get();

    //         $selectedRun = null;
    //         $topChromosomes = collect(); // مجموعة فارغة افتراضياً

    //         // التحقق إذا كان المستخدم قد اختار عملية تشغيل معينة لعرضها
    //         if ($request->has('run_id') && $request->run_id != '') {
    //             $selectedRun = Population::find($request->run_id);
    //             if ($selectedRun) {
    //                 // جلب أفضل 5 كروموسومات لهذه العملية مرتبة حسب الجودة
    //                 $topChromosomes = $selectedRun->chromosomes()
    //                     ->orderBy('penalty_value', 'asc')
    //                     ->take(5)
    //                     ->get();
    //             }
    //         }

    //         return view('dashboard.timetable-result.index', compact(
    //             'allRuns',
    //             'selectedRun',
    //             'topChromosomes'
    //         ));
    //     } catch (Exception $e) {
    //         Log::error("Error loading timetable results index: " . $e->getMessage());
    //         return redirect()->route('dashboard.index')->with('error', 'Could not load the results page.');
    //     }
    // }
    public function index() // لم نعد بحاجة لـ $request هنا مبدئياً
    {
        try {
            // 1. جلب آخر عملية تشغيل مكتملة (latest successful run)
            $latestSuccessfulRun = Population::where('status', 'completed')
                ->orderBy('end_time', 'desc') // الأحدث حسب وقت الانتهاء
                ->first();

            $topChromosomes = collect(); // مجموعة فارغة افتراضياً

            // 2. إذا وجدنا عملية تشغيل ناجحة، جلب أفضل 5 كروموسومات منها
            if ($latestSuccessfulRun) {
                $topChromosomes = $latestSuccessfulRun->chromosomes()
                    ->orderBy('penalty_value', 'asc') // الأقل عقوبة (الأفضل) في الأعلى
                    ->take(5) // جلب أفضل 5 فقط
                    ->get();
            }

            // 3. تمرير البيانات للـ View
            return view('dashboard.algorithm.timetable-result.index', compact(
                'latestSuccessfulRun', // تمرير معلومات عملية التشغيل نفسها
                'topChromosomes'
            ));
        } catch (Exception $e) {
            Log::error('Error loading timetable results index: ' . $e->getMessage());
            return redirect()->route('dashboard.index')->with('error', 'Could not load the results page.');
        }
    }

    /**
     * Display the best timetable for a given CHROMSOME.
     */
    public function show(Chromosome $chromosome) // استخدام Route Model Binding لـ Chromosome
    {
        try {
            // تحميل المعلومات المرتبطة بالكروموسوم (عملية التشغيل)
            $chromosome->load('population');

            // جلب كل الجينات (المحاضرات) مع كل تفاصيلها اللازمة للعرض
            $genes = $chromosome->genes()->with([
                'section.planSubject.subject',
                'instructor.user',
                'room.roomType',
                'timeslot'
            ])->get();

            // استخدام Service لفحص التعارضات وتحديدها
            $conflictChecker = new ConflictCheckerService($genes);
            $conflicts = $conflictChecker->getConflicts();
            $conflictingGeneIds = $conflictChecker->getConflictingGeneIds();

            // جلب كل الفترات الزمنية المتاحة لعرض هيكل الجدول
            $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');

            // تحضير بيانات الجدول للعرض
            $scheduleData = [];
            foreach ($genes as $gene) {
                if ($gene->timeslot) {
                    $scheduleData[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene;
                }
            }

            return view('dashboard.algorithm.timetable-result.show', compact(
                'chromosome', // تم تغيير اسم المتغير
                'scheduleData',
                'timeslots',
                'conflicts',
                'conflictingGeneIds'
            ));
        } catch (Exception $e) {
            Log::error("Error showing timetable result for Chromosome ID {$chromosome->chromosome_id}: " . $e->getMessage());
            return redirect()->route('dashboard.timetable.results.index')->with('error', 'Could not display the schedule result.');
        }
    }
}
-----------------------------------------------------------------------------------------------------
app\Http\Controllers\Algorithm\TimetableViewController.php
<?php

namespace App\Http\Controllers\Algorithm;

use App\Models\Plan;
use App\Models\Timeslot;
use App\Models\Chromosome;
use App\Models\Population;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;

class TimetableViewController extends Controller
{
    /**
     * جلب الجينات الخاصة بأفضل جدول دراسي
     */
    // private function getBestTimetableGenes()
    // {
    //     // جلب آخر عملية تشغيل مكتملة
    //     $lastSuccessfulRun = Population::where('status', 'completed')
    //         ->orderBy('end_time', 'desc')
    //         ->first();

    //     if (!$lastSuccessfulRun || !$lastSuccessfulRun->best_chromosome_id) {
    //         return null; // لا يوجد جدول لعرضه
    //     }

    //     // جلب أفضل كروموسوم
    //     $bestChromosome = Chromosome::find($lastSuccessfulRun->best_chromosome_id);
    //     if (!$bestChromosome) {
    //         return null;
    //     }

    //     // جلب كل الجينات (المحاضرات) مع كل تفاصيلها اللازمة للعرض
    //     return $bestChromosome->genes()->with([
    //         'section.planSubject.subject',
    //         'section.planSubject.plan',
    //         'instructor.user',
    //         'room',
    //         'timeslot'
    //     ])->get();
    // }

    // /**
    //  * 1. عرض جداول الشعب
    //  */
    // public function viewSectionTimetables(Request $request)
    // {
    //     $genes = $this->getBestTimetableGenes();
    //     if (is_null($genes)) {
    //         return view('dashboard.timetables.no-result'); // صفحة بسيطة تخبر المستخدم بعدم وجود جدول
    //     }

    //     // تحضير بيانات الجداول (مجمعة حسب الشعبة)
    //     $timetablesBySection = [];
    //     $allSectionsInTimetable = $genes->pluck('section')->unique('id'); // قائمة بالشعب الموجودة في الجدول فقط

    //     // تطبيق الفلاتر
    //     $filteredSections = $allSectionsInTimetable;
    //     if ($request->filled('plan_id')) {
    //         $filteredSections = $filteredSections->filter(fn($section) => optional(optional($section->planSubject)->plan)->id == $request->plan_id);
    //     }
    //     // ... (يمكن إضافة فلاتر أخرى بنفس الطريقة) ...


    //     foreach ($filteredSections as $section) {
    //         // جلب جينات هذه الشعبة المحددة
    //         $sectionGenes = $genes->where('section_id', $section->id);

    //         // تحضير شبكة الجدول لهذه الشعبة
    //         $scheduleGrid = [];
    //         foreach ($sectionGenes as $gene) {
    //             if ($gene->timeslot) {
    //                 $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene;
    //             }
    //         }
    //         $timetablesBySection[$section->id] = [
    //             'section' => $section,
    //             'schedule' => $scheduleGrid
    //         ];
    //     }

    //     // جلب بيانات الفلاتر
    //     $plans = Plan::where('is_active', true)->orderBy('plan_name')->get();
    //     // ... (جلب باقي بيانات الفلاتر: الأقسام، المستويات...)

    //     // جلب كل الفترات الزمنية لعرض هيكل الجدول
    //     $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');


    //     return view('dashboard.timetables.sections', compact(
    //         'timetablesBySection',
    //         'timeslots',
    //         'plans',
    //         'request'
    //         // ... (باقي بيانات الفلاتر)
    //     ));
    // }

    // private function getBestTimetableGenes()
    // {
    //     $lastSuccessfulRun = Population::where('status', 'completed')->orderBy('end_time', 'desc')->first();
    //     if (!$lastSuccessfulRun || !$lastSuccessfulRun->best_chromosome_id) {
    //         return null;
    //     }
    //     $bestChromosome = Chromosome::find($lastSuccessfulRun->best_chromosome_id);
    //     if (!$bestChromosome) {
    //         return null;
    //     }
    //     return $bestChromosome->genes()->with([
    //         'section.planSubject.subject.subjectCategory',
    //         'section.planSubject.plan',
    //         'instructor.user',
    //         'room',
    //         'timeslot'
    //     ])->get();
    // }

    // public function viewSectionTimetables(Request $request)
    // {
    //     // التحقق من وجود بيانات أساسية
    //     $allGenes = $this->getBestTimetableGenes();
    //     if (is_null($allGenes) || $allGenes->isEmpty()) {
    //         return view('dashboard.timetables.no-result');
    //     }

    //     // 1. فلترة الجينات بناءً على السياق المحدد من المستخدم (خطة، مستوى، سنة، فصل...)
    //     // هذا الجزء يحتاج لفلاتر في الـ view وتطبيقها هنا
    //     // للتبسيط الآن، سنفترض أننا نريد عرض شعب خطة ومستوى وفصل معين
    //     $planId = $request->input('plan_id', 1); // مثال: فلتر حسب الخطة ID=1
    //     $level = $request->input('plan_level', 1); // مثال: المستوى الأول
    //     $semester = $request->input('plan_semester', 1); // مثال: الفصل الأول
    //     $academicYear = $request->input('academic_year', 2025); // مثال: السنة
    //     // ... (يمكن إضافة فرع)

    //     $genesForContext = $allGenes->filter(function ($gene) use ($planId, $level, $semester, $academicYear) {
    //         return optional(optional($gene->section)->planSubject)->plan_id == $planId &&
    //             optional($gene->section->planSubject)->plan_level == $level &&
    //             optional($gene->section->planSubject)->plan_semester == $semester &&
    //             $gene->section->academic_year == $academicYear;
    //     });

    //     if ($genesForContext->isEmpty()) {
    //         // لا يوجد محاضرات مجدولة لهذا السياق
    //         return view('dashboard.timetables.sections', [
    //             'timetablesByMainSection' => [],
    //             'timeslots' => Timeslot::orderBy('start_time')->get()->groupBy('day'),
    //             'plans' => Plan::where('is_active', true)->get(),
    //             'request' => $request,
    //             'contextInfo' => "No scheduled classes found for the selected context."
    //         ]);
    //     }


    //     // 2. تحديد عدد الجداول الرئيسية (الشعب الرئيسية)
    //     // هو أكبر رقم شعبة عملية (section_number) في هذا السياق
    //     $maxPracticalSectionNumber = $genesForContext->filter(fn($gene) => $gene->section->activity_type == 'Practical')
    //         ->max('section.section_number') ?? 0;
    //     // إذا لم يكن هناك شعب عملية، قد نعتمد على عدد الشعب النظرية
    //     if ($maxPracticalSectionNumber == 0) {
    //         $maxPracticalSectionNumber = $genesForContext->filter(fn($gene) => $gene->section->activity_type == 'Theory')
    //             ->max('section.section_number') ?? 1;
    //     }

    //     // 3. جلب كل الشعب النظرية في هذا السياق
    //     $theorySections = $genesForContext->filter(fn($gene) => $gene->section->activity_type == 'Theory')
    //         ->pluck('section')->unique('id');
    //     $numberOfTheorySections = $theorySections->count();


    //     // 4. بناء كل جدول رئيسي
    //     $timetablesByMainSection = [];
    //     for ($mainSectionNum = 1; $mainSectionNum <= $maxPracticalSectionNumber; $mainSectionNum++) {
    //         $allGenesForThisMainSection = collect();

    //         // أ. إضافة المحاضرات العملية الخاصة بهذه الشعبة الرئيسية
    //         $practicalGenes = $genesForContext->filter(function ($gene) use ($mainSectionNum) {
    //             return $gene->section->activity_type == 'Practical' &&
    //                 $gene->section->section_number == $mainSectionNum;
    //         });
    //         $allGenesForThisMainSection = $allGenesForThisMainSection->merge($practicalGenes);

    //         // ب. إضافة المحاضرات النظرية المشتركة
    //         if ($numberOfTheorySections == 1) {
    //             // إذا كانت هناك شعبة نظرية واحدة فقط، فهي مشتركة للجميع
    //             $allGenesForThisMainSection = $allGenesForThisMainSection->merge($theorySections->pluck('genes')->flatten());
    //         } elseif ($numberOfTheorySections > 1) {
    //             // منطق توزيع الشعب العملية على الشعب النظرية
    //             // مثال بسيط: الشعب العملية الفردية (1,3,5) مع النظرية 1، والزوجية (2,4,6) مع النظرية 2
    //             $theorySectionIndex = ($mainSectionNum - 1) % $numberOfTheorySections; // 0, 1, 0, 1...
    //             $assignedTheorySection = $theorySections->values()->get($theorySectionIndex);
    //             if ($assignedTheorySection) {
    //                 $allGenesForThisMainSection = $allGenesForThisMainSection->merge($assignedTheorySection->genes);
    //             }
    //         }

    //         // بناء شبكة الجدول لهذه الشعبة الرئيسية
    //         $scheduleGrid = [];
    //         foreach ($allGenesForThisMainSection->unique('id') as $gene) {
    //             if ($gene->timeslot) {
    //                 $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene;
    //             }
    //         }
    //         // اسم الشعبة الرئيسية
    //         $sectionTitle = "Section {$mainSectionNum}";
    //         $timetablesByMainSection[$mainSectionNum] = [
    //             'title' => $sectionTitle,
    //             'schedule' => $scheduleGrid
    //         ];
    //     }

    //     // جلب بيانات الفلاتر
    //     $plans = Plan::where('is_active', true)->orderBy('plan_name')->get();
    //     $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');
    //     $contextInfo = "Displaying {$maxPracticalSectionNumber} main section(s) for Plan: {$genesForContext->first()->section->planSubject->plan->plan_no}, Level: {$level}, Term: {$semester}";

    //     return view('dashboard.timetables.sections', compact(
    //         'timetablesByMainSection',
    //         'timeslots',
    //         'plans',
    //         'request',
    //         'contextInfo'
    //     ));
    // }

    // private function getBestTimetableGenes()
    // {
    //     $lastSuccessfulRun = Population::where('status', 'completed')->orderBy('end_time', 'desc')->first();
    //     if (!$lastSuccessfulRun || !$lastSuccessfulRun->best_chromosome_id) { return null; }
    //     $bestChromosome = \App\Models\Chromosome::find($lastSuccessfulRun->best_chromosome_id);
    //     if (!$bestChromosome) { return null; }
    //     return $bestChromosome->genes()->with([
    //         'section.planSubject.subject.subjectCategory',
    //         'section.planSubject.plan.department', // تحميل كل العلاقات اللازمة
    //         'instructor.user',

    //         'room',
    //         'timeslot'
    //     ])->get();
    // }

    /**
     * عرض جداول الشعب (بالمنطق الجديد والمحسن)
     */
    // public function viewSectionTimetables(Request $request)
    // {
    //     $allGenes = $this->getBestTimetableGenes();
    //     if (is_null($allGenes) || $allGenes->isEmpty()) {
    //         return view('dashboard.timetables.no-result');
    //     }

    //     // --- 1. فلترة الجينات بناءً على السياق المحدد من المستخدم ---
    //     $genesForContext = $allGenes;
    //     if ($request->filled('plan_id')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_id == $request->plan_id);
    //     }
    //     if ($request->filled('plan_level')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_level == $request->plan_level);
    //     }
    //     if ($request->filled('plan_semester')) { // هذا هو فصل الخطة
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_semester == $request->plan_semester);
    //     }
    //     if ($request->filled('academic_year')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional($gene->section)->academic_year == $request->academic_year);
    //     }
    //     // ... (يمكن إضافة فلاتر أخرى بنفس الطريقة) ...

    //     // --- 2. تجميع الجينات حسب "المجموعة" (السياق) ---
    //     // المفتاح هو: plan_id-level-semester-year-branch
    //     $genesGroupedByContext = $genesForContext->groupBy(function ($gene) {
    //         $section = $gene->section;
    //         if (!$section || !$section->planSubject) return 'unknown';
    //         return implode('-', [
    //             $section->planSubject->plan_id,
    //             $section->planSubject->plan_level,
    //             $section->planSubject->plan_semester,
    //             $section->academic_year,
    //             $section->branch ?? 'default'
    //         ]);
    //     });


    //     // --- 3. بناء الجداول لكل مجموعة ---
    //     $timetablesByContext = [];
    //     foreach ($genesGroupedByContext as $contextKey => $genesInContext) {
    //         if ($contextKey === 'unknown') continue;

    //         $firstGene = $genesInContext->first();
    //         $contextInfo = [
    //             'plan' => optional(optional($firstGene->section)->planSubject)->plan,
    //             'level' => optional($firstGene->section->planSubject)->plan_level,
    //             'semester' => optional($firstGene->section->planSubject)->plan_semester,
    //             'year' => $firstGene->section->academic_year,
    //             'branch' => $firstGene->section->branch,
    //         ];

    //         // تحديد عدد الجداول الرئيسية (الشعب) لهذه المجموعة
    //         $maxPracticalSectionNumber = $genesInContext->filter(fn($g) => $g->section->activity_type == 'Practical')->max('section.section_number') ?? 0;
    //         if ($maxPracticalSectionNumber == 0) {
    //              $maxPracticalSectionNumber = $genesInContext->filter(fn($g) => $g->section->activity_type == 'Theory')->max('section.section_number') ?? 1;
    //         }

    //         $timetablesForThisContext = [];
    //         for ($mainSectionNum = 1; $mainSectionNum <= $maxPracticalSectionNumber; $mainSectionNum++) {
    //             // أ. جلب المحاضرات العملية لهذه الشعبة الرئيسية (لكل المواد)
    //             $practicalGenes = $genesInContext->filter(function ($gene) use ($mainSectionNum) {
    //                 return $gene->section->activity_type == 'Practical' && $gene->section->section_number == $mainSectionNum;
    //             });

    //             // ب. جلب المحاضرات النظرية المشتركة
    //             $theoryGenes = $genesInContext->filter(fn($gene) => $gene->section->activity_type == 'Theory');

    //             // ج. دمج المحاضرات
    //             $allGenesForThisMainSection = $practicalGenes->merge($theoryGenes);

    //             // د. بناء شبكة الجدول
    //             $scheduleGrid = [];
    //             foreach ($allGenesForThisMainSection->unique('id') as $gene) {
    //                 if ($gene->timeslot) { $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene; }
    //             }

    //             $timetablesForThisContext[] = [
    //                 'title' => "Section {$mainSectionNum}",
    //                 'schedule' => $scheduleGrid
    //             ];
    //         }
    //         $timetablesByContext[$contextKey] = ['info' => $contextInfo, 'timetables' => $timetablesForThisContext];
    //     }


    //     // جلب بيانات الفلاتر
    //     $plans = Plan::where('is_active', true)->orderBy('plan_name')->get();
    //     $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');
    //     // ... (جلب باقي بيانات الفلاتر إذا احتجت)

    //     return view('dashboard.timetables.sections', compact(
    //         'timetablesByContext',
    //         'timeslots',
    //         'plans',
    //         'request',
    //         'timetablesForThisContext'
    //     ));
    // }

    // public function viewSectionTimetables(Request $request)
    // {
    //     $allGenes = $this->getBestTimetableGenes();
    //     if (is_null($allGenes) || $allGenes->isEmpty()) {
    //         return view('dashboard.timetables.no-result');
    //     }

    //     // --- 1. فلترة الجينات بناءً على السياق المحدد من المستخدم ---
    //     $genesForContext = $allGenes;
    //     if ($request->filled('plan_id')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_id == $request->plan_id);
    //     }
    //     if ($request->filled('plan_level')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_level == $request->plan_level);
    //     }
    //     if ($request->filled('academic_year')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional($gene->section)->academic_year == $request->academic_year);
    //     }
    //     // ... (يمكن إضافة فلاتر أخرى: فصل، فرع) ...

    //     // --- 2. تجميع الجينات حسب "المجموعة" (السياق) ---
    //     $genesGroupedByContext = $genesForContext->groupBy(function ($gene) {
    //         $section = $gene->section;
    //         if (!$section || !$section->planSubject) return 'unknown';
    //         return implode('-', [
    //             $section->planSubject->plan_id,
    //             $section->planSubject->plan_level,
    //             $section->planSubject->plan_semester, // فصل الخطة
    //             $section->academic_year,
    //             $section->branch ?? 'default'
    //         ]);
    //     });


    //     // --- 3. بناء الجداول لكل مجموعة ---
    //     $timetablesByContext = [];
    //     foreach ($genesGroupedByContext as $contextKey => $genesInContext) {
    //         if ($contextKey === 'unknown' || $genesInContext->isEmpty()) continue;

    //         $firstGene = $genesInContext->first();
    //         $contextInfo = [
    //             'plan' => optional(optional($firstGene->section)->planSubject)->plan,
    //             'level' => optional($firstGene->section->planSubject)->plan_level,
    //             'semester' => optional($firstGene->section->planSubject)->plan_semester, // فصل الخطة
    //             'year' => $firstGene->section->academic_year,
    //             'branch' => $firstGene->section->branch,
    //         ];

    //         // 4. تحديد عدد الجداول الرئيسية (الشعب الرئيسية)
    //         $maxSectionNumber = $genesInContext->pluck('section.section_number')->max() ?? 1;

    //         // 5. جلب كل المحاضرات النظرية المشتركة لهذا السياق
    //         $theoryGenes = $genesInContext->filter(fn($gene) => $gene->section->activity_type == 'Theory');

    //         $timetablesForThisContext = [];
    //         for ($mainSectionNum = 1; $mainSectionNum <= $maxSectionNumber; $mainSectionNum++) {
    //             // أ. جلب المحاضرات العملية الخاصة بهذه الشعبة الرئيسية (لكل المواد)
    //             $practicalGenes = $genesInContext->filter(function ($gene) use ($mainSectionNum) {
    //                 return $gene->section->activity_type == 'Practical' &&
    //                        $gene->section->section_number == $mainSectionNum;
    //             });

    //             // ب. دمج المحاضرات العملية مع المحاضرات النظرية المشتركة
    //             $allGenesForThisMainSection = $practicalGenes->merge($theoryGenes);

    //             // د. بناء شبكة الجدول
    //             $scheduleGrid = [];
    //             foreach ($allGenesForThisMainSection->unique('id') as $gene) {
    //                 if ($gene->timeslot) { $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene; }
    //             }

    //             $timetablesForThisContext[] = [
    //                 'title' => "Section {$mainSectionNum}",
    //                 'schedule' => $scheduleGrid
    //             ];
    //         }
    //         $timetablesByContext[$contextKey] = ['info' => $contextInfo, 'timetables' => $timetablesForThisContext];
    //     }


    //     // جلب بيانات الفلاتر
    //     $plans = Plan::where('is_active', true)->orderBy('plan_name')->get();
    //     $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');
    //     // ... (جلب باقي بيانات الفلاتر إذا احتجت)

    //     return view('dashboard.timetables.sections', compact(
    //         'timetablesByContext',
    //         'timeslots',
    //         'plans',
    //         'request'
    //     ));
    // }
    // **********************************************************************************
    // private function getBestTimetableGenes()
    // {
    //     $lastSuccessfulRun = Population::where('status', 'completed')->orderBy('end_time', 'desc')->first();
    //     if (!$lastSuccessfulRun || !$lastSuccessfulRun->best_chromosome_id) { return null; }
    //     $bestChromosome = \App\Models\Chromosome::find($lastSuccessfulRun->best_chromosome_id);
    //     if (!$bestChromosome) { return null; }
    //     return $bestChromosome->genes()->with([
    //         'section.planSubject.subject.subjectCategory',
    //         'section.planSubject.plan.department',
    //         'instructor.user',
    //         'room',
    //         'timeslot'
    //     ])->get();
    // }

    // /**
    //  * عرض جداول الشعب (بالمنطق الصحيح والمضمون)
    //  */
    // public function viewSectionTimetables(Request $request)
    // {
    //     $allGenes = $this->getBestTimetableGenes();
    //     if (is_null($allGenes) || $allGenes->isEmpty()) {
    //         return view('dashboard.timetables.no-result');
    //     }

    //     // --- 1. فلترة الجينات بناءً على السياق المحدد من المستخدم (إذا وجد) ---
    //     $genesForContext = $allGenes;
    //     if ($request->filled('plan_id')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_id == $request->plan_id);
    //     }
    //     if ($request->filled('plan_level')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_level == $request->plan_level);
    //     }
    //     if ($request->filled('academic_year')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional($gene->section)->academic_year == $request->academic_year);
    //     }
    //     // ... (فلاتر أخرى) ...

    //     // --- 2. تجميع الجينات حسب "المجموعة" (السياق) ---
    //     $genesGroupedByContext = $genesForContext->groupBy(function ($gene) {
    //         $section = $gene->section;
    //         if (!$section || !$section->planSubject) return 'unknown';
    //         return implode('-', [
    //             $section->planSubject->plan_id,
    //             $section->planSubject->plan_level,
    //             $section->planSubject->plan_semester,
    //             $section->academic_year,
    //             $section->branch ?? 'default'
    //         ]);
    //     });


    //     // --- 3. بناء الجداول لكل مجموعة ---
    //     $timetablesByContext = [];
    //     foreach ($genesGroupedByContext as $contextKey => $genesInContext) {
    //         if ($contextKey === 'unknown' || $genesInContext->isEmpty()) continue;

    //         $firstGene = $genesInContext->first();
    //         $contextInfo = [
    //             'plan' => optional(optional($firstGene->section)->planSubject)->plan,
    //             'level' => optional($firstGene->section->planSubject)->plan_level,
    //             'semester' => optional($firstGene->section->planSubject)->plan_semester,
    //             'year' => $firstGene->section->academic_year,
    //             'branch' => $firstGene->section->branch,
    //         ];

    //         // 4. تحديد عدد الجداول الرئيسية (أكبر رقم شعبة)
    //         $maxSectionNumber = $genesInContext->pluck('section.section_number')->max() ?? 1;

    //         // 5. جلب كل المحاضرات النظرية المشتركة لهذا السياق
    //         $theoryGenesInContext = $genesInContext->filter(fn($gene) => $gene->section->activity_type == 'Theory');

    //         $timetablesForThisContext = [];
    //         for ($mainSectionNum = 1; $mainSectionNum <= $maxSectionNumber; $mainSectionNum++) {
    //             // أ. جلب المحاضرات العملية الخاصة بهذه الشعبة الرئيسية (لكل المواد)
    //             $practicalGenesForThisSection = $genesInContext->filter(function ($gene) use ($mainSectionNum) {
    //                 return $gene->section->activity_type == 'Practical' &&
    //                        $gene->section->section_number == $mainSectionNum;
    //             });

    //             // ب. *** دمج المحاضرات العملية مع كل المحاضرات النظرية المشتركة ***
    //             $allGenesForThisMainSection = $practicalGenesForThisSection->merge($theoryGenesInContext);

    //             // د. بناء شبكة الجدول
    //             if ($allGenesForThisMainSection->isNotEmpty()) { // فقط أنشئ جدولاً إذا كان هناك محاضرات
    //                 $scheduleGrid = [];
    //                 foreach ($allGenesForThisMainSection->unique('id') as $gene) {
    //                     if ($gene->timeslot) { $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene; }
    //                 }
    //                 $timetablesForThisContext[] = [
    //                     'title' => "Section {$mainSectionNum}",
    //                     'schedule' => $scheduleGrid
    //                 ];
    //             }
    //         }
    //         if (!empty($timetablesForThisContext)) {
    //              $timetablesByContext[$contextKey] = ['info' => $contextInfo, 'timetables' => $timetablesForThisContext];
    //         }
    //     }


    //     // جلب بيانات الفلاتر
    //     $plans = Plan::where('is_active', true)->orderBy('plan_name')->get();
    //     $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');
    //     // ... (جلب باقي بيانات الفلاتر إذا احتجت)

    //     return view('dashboard.timetables.sections', compact(
    //         'timetablesByContext',
    //         'timeslots',
    //         'plans',
    //         'request'
    //     ));
    // }

    // دالة getBestTimetableGenes تبقى كما هي
    private function getBestTimetableGenes()
    {
        $lastSuccessfulRun = Population::where('status', 'completed')->orderBy('end_time', 'desc')->first();
        if (!$lastSuccessfulRun || !$lastSuccessfulRun->best_chromosome_id) {
            return null;
        }
        $bestChromosome = \App\Models\Chromosome::find($lastSuccessfulRun->best_chromosome_id);
        if (!$bestChromosome) {
            return null;
        }
        return $bestChromosome->genes()->with([
            'section.planSubject.subject.subjectCategory',
            'section.planSubject.plan.department',
            'instructor.user',
            'room',
            'timeslot'
        ])->get();
    }

    /**
     * عرض جداول الشعب (بالمنطق الصحيح والمضمون)
     */
    // public function viewSectionTimetables(Request $request)
    // {
    //     $allGenes = $this->getBestTimetableGenes();
    //     if (is_null($allGenes) || $allGenes->isEmpty()) {
    //         return view('dashboard.timetables.no-result');
    //     }

    //     // 1. فلترة الجينات بناءً على السياق المحدد من المستخدم (إذا وجد)
    //     $genesForContext = $allGenes;

    //     if ($request->filled('plan_id')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_id == $request->plan_id);
    //     }
    //     if ($request->filled('plan_level')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_level == $request->plan_level);
    //     }
    //     if ($request->filled('academic_year')) {
    //         $genesForContext = $genesForContext->filter(fn($gene) => optional($gene->section)->academic_year == $request->academic_year);
    //     }
    //     // ... (فلاتر أخرى) ...

    //     // 2. تجميع الجينات حسب "المجموعة" (السياق)
    //     $genesGroupedByContext = $genesForContext->groupBy(function ($gene) {
    //         $section = $gene->section;
    //         if (!$section || !$section->planSubject) return 'unknown';
    //         return implode('-', [
    //             $section->planSubject->plan_id,
    //             $section->planSubject->plan_level,
    //             $section->planSubject->plan_semester,
    //             $section->academic_year,
    //             $section->branch ?? 'default'
    //         ]);
    //     });

    //     // 3. بناء الجداول لكل مجموعة
    //     $timetablesByContext = [];
    //     foreach ($genesGroupedByContext as $contextKey => $genesInContext) {
    //         if ($contextKey === 'unknown' || $genesInContext->isEmpty()) continue;

    //         $firstGene = $genesInContext->first();
    //         $contextInfo = [
    //             'plan' => optional(optional($firstGene->section)->planSubject)->plan,
    //             'level' => optional($firstGene->section->planSubject)->plan_level,
    //             'semester' => optional($firstGene->section->planSubject)->plan_semester,
    //             'year' => $firstGene->section->academic_year,
    //             'branch' => $firstGene->section->branch,
    //         ];

    //         // 4. تحديد عدد الجداول الرئيسية (أكبر رقم شعبة عملية)
    //         $maxPracticalSectionNumber = $genesInContext->filter(fn($g) => $g->section->activity_type == 'Practical')->max('section.section_number');
    //         // إذا لم يكن هناك شعب عملية، افترض وجود شعبة رئيسية واحدة على الأقل
    //         if (empty($maxPracticalSectionNumber) || $maxPracticalSectionNumber < 1) {
    //             $maxPracticalSectionNumber = 1;
    //         }

    //         // 5. *** استخراج كل المحاضرات النظرية لهذا السياق ***
    //         $theoryGenesInContext = $genesInContext->filter(fn($gene) => $gene->section->activity_type == 'Theory' || $gene->section->activity_type == 'نظري' || $gene->section->activity_type == 'theory');

    //         $timetablesForThisContext = [];
    //         for ($mainSectionNum = 0; $mainSectionNum <= $maxPracticalSectionNumber; $mainSectionNum++) {
    //             // أ. جلب المحاضرات العملية الخاصة بهذه الشعبة الرئيسية (لكل المواد)
    //             $practicalGenesForThisSection = $genesInContext->filter(function ($gene) use ($mainSectionNum) {
    //                 return $gene->section->activity_type == 'Practical' &&
    //                     $gene->section->section_number == $mainSectionNum;
    //             });

    //             // ب. *** دمج المحاضرات العملية مع كل المحاضرات النظرية المشتركة ***
    //             // هذا هو السطر الصحيح للدمج
    //             $allGenesForThisMainSection = $practicalGenesForThisSection->merge($theoryGenesInContext);

    //             // د. بناء شبكة الجدول
    //             if ($allGenesForThisMainSection->isNotEmpty()) {
    //                 $scheduleGrid = [];
    //                 foreach ($allGenesForThisMainSection->unique('id') as $gene) {
    //                     // if ($gene->timeslot) {
    //                         $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene;
    //                     // }
    //                 }
    //                 $timetablesForThisContext[] = [
    //                     'title' => "Section {$mainSectionNum}",
    //                     'schedule' => $scheduleGrid
    //                 ];
    //             }
    //         }
    //         if (!empty($timetablesForThisContext)) {
    //             $timetablesByContext[$contextKey] = ['info' => $contextInfo, 'timetables' => $timetablesForThisContext];
    //         }
    //     }

    //     dd([
    //         // '$allGenes' => $allGenes,
    //         // '$genesForContext' => $genesForContext,
    //         // '$genesGroupedByContext' => $genesGroupedByContext,
    //         // '$section' => $gene->section,
    //         // '$timetablesByContext' => $timetablesByContext,
    //         // '$firstGene' => $firstGene,
    //         // '$contextInfo' => $contextInfo,
    //         // '$maxPracticalSectionNumber' => $maxPracticalSectionNumber,
    //         // '$timetablesForThisContext' => $timetablesForThisContext,
    //         // '$theoryGenesInContext' => $theoryGenesInContext,
    //         '$practicalGenesForThisSection' => $practicalGenesForThisSection,
    //         '$allGenesForThisMainSection' => $allGenesForThisMainSection,
    //         '$scheduleGrid' => $scheduleGrid,
    //     ]);


    //     // جلب بيانات الفلاتر
    //     $plans = Plan::where('is_active', true)->orderBy('plan_name')->get();
    //     $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');
    //     // ... (جلب باقي بيانات الفلاتر إذا احتجت)

    //     return view('dashboard.timetables.sections', compact(
    //         'timetablesByContext',
    //         'timeslots',
    //         'plans',
    //         'request'
    //     ));
    // }

    public function viewSectionTimetables(Request $request)
    {
        $allGenes = $this->getBestTimetableGenes();
        if (is_null($allGenes) || $allGenes->isEmpty()) {
            return view('dashboard.timetables.no-result');
        }

        // --- 1. فلترة الجينات بناءً على السياق المحدد من المستخدم ---
        $genesForContext = $allGenes;
        if ($request->filled('plan_id')) { $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_id == $request->plan_id); }
        if ($request->filled('plan_level')) { $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_level == $request->plan_level); }
        if ($request->filled('plan_semester')) { $genesForContext = $genesForContext->filter(fn($gene) => optional(optional($gene->section)->planSubject)->plan_semester == $request->plan_semester); }
        if ($request->filled('academic_year')) { $genesForContext = $genesForContext->filter(fn($gene) => optional($gene->section)->academic_year == $request->academic_year); }
        // ... (يمكن إضافة فلاتر أخرى) ...

        // --- 2. تجميع الجينات حسب "المجموعة" (السياق) ---
        $genesGroupedByContext = $genesForContext->groupBy(function ($gene) {
            $section = $gene->section;
            if (!$section || !$section->planSubject) return 'unknown';
            return implode('-', [
                $section->planSubject->plan_id, $section->planSubject->plan_level,
                $section->planSubject->plan_semester, $section->academic_year, $section->branch ?? 'default'
            ]);
        });


        // --- 3. بناء الجداول لكل مجموعة ---
        $timetablesByContext = [];
        foreach ($genesGroupedByContext as $contextKey => $genesInContext) {
            if ($contextKey === 'unknown' || $genesInContext->isEmpty()) continue;

            $firstGene = $genesInContext->first();
            $contextInfo = [
                'plan' => optional(optional($firstGene->section)->planSubject)->plan,
                'level' => optional($firstGene->section->planSubject)->plan_level,
                'semester' => optional($firstGene->section->planSubject)->plan_semester,
                'year' => $firstGene->section->academic_year,
                'branch' => $firstGene->section->branch,
            ];

            // تحديد عدد الجداول الرئيسية (أكبر رقم شعبة عملية)
            $maxSectionNumber = $genesInContext->filter(fn($g) => $g->section->activity_type == 'Practical')->max('section.section_number') ?? 0;
            if ($maxSectionNumber == 0) {
                 $maxSectionNumber = $genesInContext->filter(fn($g) => $g->section->activity_type == 'Theory')->max('section.section_number') ?? 1;
            }

            // جلب كل الشعب النظرية في هذا السياق
            $theoryGenes = $genesInContext->filter(fn($g) => $g->section->activity_type == 'Theory');
            $theorySections = $theoryGenes->pluck('section')->unique('id')->sortBy('section_number'); // الشعب النظرية مرتبة
            $numberOfTheorySections = $theorySections->count();

            $timetablesForThisContext = [];
            for ($mainSectionNum = 1; $mainSectionNum <= $maxSectionNumber; $mainSectionNum++) {
                $allGenesForThisMainSection = collect();

                // أ. جلب المحاضرات العملية لهذه الشعبة الرئيسية (لكل المواد)
                $practicalGenes = $genesInContext->filter(function ($gene) use ($mainSectionNum) {
                    return $gene->section->activity_type == 'Practical' &&
                           $gene->section->section_number == $mainSectionNum;
                });
                $allGenesForThisMainSection = $allGenesForThisMainSection->merge($practicalGenes);

                // ب. جلب المحاضرات النظرية المشتركة
                if ($numberOfTheorySections == 1) {
                    // إذا كانت هناك شعبة نظرية واحدة فقط، فهي مشتركة للجميع
                    $allGenesForThisMainSection = $allGenesForThisMainSection->merge($theoryGenes);
                } elseif ($numberOfTheorySections > 1) {
                    // منطق توزيع الشعب العملية على الشعب النظرية
                    $theorySectionIndex = ($mainSectionNum - 1) % $numberOfTheorySections;
                    $assignedTheorySection = $theorySections->values()->get($theorySectionIndex);
                    if ($assignedTheorySection) {
                         // جلب الجينات الخاصة بهذه الشعبة النظرية فقط
                         $assignedTheoryGenes = $theoryGenes->where('section_id', $assignedTheorySection->id);
                         $allGenesForThisMainSection = $allGenesForThisMainSection->merge($assignedTheoryGenes);
                    }
                }

                // بناء شبكة الجدول
                $scheduleGrid = [];
                foreach ($allGenesForThisMainSection->unique('gene_id') as $gene) {
                    if ($gene->timeslot) { $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene; }
                }

                $timetablesForThisContext[] = [
                    'title' => "Section {$mainSectionNum}",
                    'schedule' => $scheduleGrid
                ];
            }
            $timetablesByContext[$contextKey] = ['info' => $contextInfo, 'timetables' => $timetablesForThisContext];
        }


        dd([
            // '$genesGroupedByContext' => $genesGroupedByContext,
            '$timetablesByContext' => $timetablesByContext,
        ]);


        // جلب بيانات الفلاتر (نفس الكود السابق)
        $plans = Plan::where('is_active', true)->orderBy('plan_name')->get();
        $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');
        // ...

        return view('dashboard.timetables.sections', compact(
            'timetablesByContext',
            'timeslots',
            'plans', // لتعبئة الفلتر
            'request'
            // ... يمكنك تمرير باقي بيانات الفلاتر هنا ...
        ));
    }

    /**
     * 2. عرض جداول المدرسين
     */
    public function viewInstructorTimetables(Request $request)
    {
        $genes = $this->getBestTimetableGenes();
        if (is_null($genes)) {
            return view('dashboard.timetables.no-result');
        }

        // تحضير بيانات الجداول (مجمعة حسب المدرس)
        $timetablesByInstructor = [];
        $allInstructorsInTimetable = $genes->pluck('instructor')->unique('id')->sortBy(fn($inst) => optional($inst->user)->name);

        // تطبيق الفلاتر
        $filteredInstructors = $allInstructorsInTimetable;
        if ($request->filled('instructor_id')) {
            $filteredInstructors = $filteredInstructors->where('id', $request->instructor_id);
        }
        // ... (يمكن إضافة فلتر حسب القسم) ...


        foreach ($filteredInstructors as $instructor) {
            $instructorGenes = $genes->where('instructor_id', $instructor->id);
            $scheduleGrid = [];
            foreach ($instructorGenes as $gene) {
                if ($gene->timeslot) {
                    $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene;
                }
            }
            $timetablesByInstructor[$instructor->id] = [
                'instructor' => $instructor,
                'schedule' => $scheduleGrid
            ];
        }

        // جلب بيانات الفلاتر (كل المدرسين)
        $instructorsForFilter = $allInstructorsInTimetable;
        $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');

        return view('dashboard.timetables.instructors', compact(
            'timetablesByInstructor',
            'timeslots',
            'instructorsForFilter',
            'request'
        ));
    }

    /**
     * 3. عرض جداول القاعات
     */
    public function viewRoomTimetables(Request $request)
    {
        $genes = $this->getBestTimetableGenes();
        if (is_null($genes)) {
            return view('dashboard.timetables.no-result');
        }

        // تحضير بيانات الجداول (مجمعة حسب القاعة)
        $timetablesByRoom = [];
        $allRoomsInTimetable = $genes->pluck('room')->unique('id')->sortBy('room_no');

        // تطبيق الفلاتر
        $filteredRooms = $allRoomsInTimetable;
        if ($request->filled('room_id')) {
            $filteredRooms = $filteredRooms->where('id', $request->room_id);
        }
        // ... (يمكن إضافة فلتر حسب نوع القاعة) ...


        foreach ($filteredRooms as $room) {
            $roomGenes = $genes->where('room_id', $room->id);
            $scheduleGrid = [];
            foreach ($roomGenes as $gene) {
                if ($gene->timeslot) {
                    $scheduleGrid[$gene->timeslot->day][$gene->timeslot->start_time][] = $gene;
                }
            }
            $timetablesByRoom[$room->id] = [
                'room' => $room,
                'schedule' => $scheduleGrid
            ];
        }

        // جلب بيانات الفلاتر (كل القاعات)
        $roomsForFilter = $allRoomsInTimetable;
        $timeslots = Timeslot::orderBy('start_time')->get()->groupBy('day');

        return view('dashboard.timetables.instructors', compact(
            'timetablesByRoom',
            'timeslots',
            'roomsForFilter',
            'request'
        ));
    }
}
---------------------------------------------------------------------------------------------------------
app\Models\Chromosome.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Chromosome extends Model
{
    use HasFactory;

    // اسم الجدول
    // protected $table = 'chromosomes';

    // اسم المفتاح الأساسي
    protected $primaryKey = 'chromosome_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = [
        'population_id',
        'penalty_value',
        'generation_number',
        'is_best_of_generation',
    ];

    /**
     * علاقة: الكروموسوم الواحد يتبع لعملية تشغيل واحدة (Population).
     */
    public function population()
    {
        // علاقة "واحد إلى واحد" مع جدول Population
        return $this->belongsTo(Population::class, 'population_id', 'population_id');
    }

    /**
     * علاقة: الكروموسوم الواحد يحتوي على عدة جينات (تفاصيل محاضرات).
     */
    public function genes()
    {
        // علاقة "واحد إلى متعدد" مع جدول Gene
        return $this->hasMany(Gene::class, 'chromosome_id', 'chromosome_id');
    }
}
---------------------------------------------------------------------------------------------------------
app\Models\CrossoverType.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class CrossoverType extends Model
{
    use HasFactory;

    // اسم الجدول في قاعدة البيانات
    // protected $table = 'crossovers';
    protected $primaryKey = 'crossover_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = ['name', 'description', 'is_active'];

    public function populations()
    {
        // علاقة "واحد إلى متعدد" مع جدول populations
        return $this->hasMany(Population::class, 'crossover_id', 'crossover_id');
    }
}
------------------------------------------------------------------------------------------------------
app\Models\Gene.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Gene extends Model
{
    use HasFactory;

    // protected $table = 'genes';
    protected $primaryKey = 'gene_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = [
        'chromosome_id',
        'section_id',
        'instructor_id',
        'room_id',
        'timeslot_id', // هذا يربط بجدول timeslots الأساسي
    ];

    /**
     * علاقة: الجين يتبع لكروموسوم واحد.
     */
    public function chromosome()
    {
        // علاقة "واحد إلى واحد" مع جدول Chromosome
        return $this->belongsTo(Chromosome::class, 'chromosome_id', 'chromosome_id');
    }

    /**
     * علاقة: الجين يمثل شعبة واحدة.
     */
    public function section()
    {
        // علاقة "واحد إلى واحد" مع جدول Section
        return $this->belongsTo(Section::class, 'section_id', 'id');
    }

    /**
     * علاقة: الجين له مدرس واحد.
     */
    public function instructor()
    {
        // علاقة "واحد إلى واحد" مع جدول Instructor
        return $this->belongsTo(Instructor::class, 'instructor_id', 'id');
    }

    /**
     * علاقة: الجين له قاعة واحدة.
     */
    public function room()
    {
        // علاقة "واحد إلى واحد" مع جدول Room
        return $this->belongsTo(Room::class, 'room_id', 'id');
    }

    /**
     * علاقة: الجين له فترة زمنية واحدة (من الجدول الأساسي).
     */
    public function timeslot()
    {
        // علاقة "واحد إلى واحد" مع جدول Timeslot
        return $this->belongsTo(Timeslot::class, 'timeslot_id', 'id');
    }

    public function algorithmTimeslot()
    {
        return $this->hasOne(Timeslot::class, 'gene_id', 'gene_id');
    }
}
--------------------------------------------------------------------------------------------------
app\Models\GeneratedSchedule.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class GeneratedSchedule extends Model
{
    use HasFactory;

    // اسم الجدول مختلف
    protected $table = 'generated_schedules';

    protected $fillable = [
        'section_id',
        'instructor_id',
        'room_id',
        'timeslot_id',
        'academic_year',
        'semester',
        'lecture_type',
    ];

    /**
     * Get the section associated with this schedule entry.
     * علاقة: إدخال الجدول يتبع لشعبة واحدة (One To Many Inverse)
     */
    public function section()
    {
        return $this->belongsTo(Section::class, 'section_id', 'id');
    }

    /**
     * Get the instructor assigned to this schedule entry.
     * علاقة: إدخال الجدول يتبع لمدرس واحد (One To Many Inverse)
     */
    public function instructor()
    {
        return $this->belongsTo(Instructor::class, 'instructor_id', 'id');
    }

    /**
     * Get the room assigned to this schedule entry.
     * علاقة: إدخال الجدول يتبع لقاعة واحدة (One To Many Inverse)
     */
    public function room()
    {
        return $this->belongsTo(Room::class, 'room_id', 'id');
    }

    /**
     * Get the timeslot for this schedule entry.
     * علاقة: إدخال الجدول يتبع لفترة زمنية واحدة (One To Many Inverse)
     */
    public function timeslot()
    {
        return $this->belongsTo(Timeslot::class, 'timeslot_id', 'id');
    }

     // يمكنك إضافة علاقات للوصول السريع للمادة والخطة واليوم والوقت من هنا
     public function subject() {
         // يجب أن يكون لديك علاقة معرفة في موديل Section للوصول للمادة
         return $this->section->subject(); // قد تحتاج لتحسين الأداء Eager Loading
     }
      public function plan() {
         // يجب أن يكون لديك علاقة معرفة في موديل Section للوصول للخطة
         return $this->section->plan();
     }
     public function dayOfWeek() {
         return $this->timeslot->day_of_week; // أو DayName إذا استخدمت الـ Accessor
     }
     public function startTime() {
         return $this->timeslot->start_time; // أو FormattedStartTime
     }
     public function endTime() {
         return $this->timeslot->end_time; // أو FormattedEndTime
     }
}
----------------------------------------------------------------------------------------------------------
app\Models\Population.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Population extends Model
{
    use HasFactory;

    // اسم الجدول
    // protected $table = 'populations';
    protected $primaryKey = 'population_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = [
        'population_size',
        'crossover_id',
        'selection_id',
        'mutation_rate',
        'generations_count',
        'best_chromosome_id',
        'start_time',
        'end_time',
        'status',
    ];

    /**
     * علاقة: عملية التشغيل الواحدة تتبع لنوع اختيار واحد.
     */
    public function selectionType()
    {
        // علاقة "واحد إلى واحد" مع جدول SelectionType
        return $this->belongsTo(SelectionType::class, 'selection_id', 'selection_type_id');
    }

    /**
     * علاقة: عملية التشغيل الواحدة تتبع لنوع تزاوج واحد.
     */
    public function crossover()
    {
        // علاقة "واحد إلى واحد" مع جدول CrossoverType
        return $this->belongsTo(CrossoverType::class, 'crossover_id', 'crossover_id');
    }

    /**
     * علاقة: عملية التشغيل الواحدة تحتوي على عدة كروموسومات (حلول مقترحة).
     */
    public function chromosomes()
    {
        // علاقة "واحد إلى متعدد" مع جدول Chromosome
        return $this->hasMany(Chromosome::class, 'population_id', 'population_id');
    }

    /**
     * علاقة: عملية التشغيل الواحدة لها أفضل كروموسوم واحد في النهاية.
     */
    public function bestChromosome()
    {
        // علاقة "واحد إلى واحد" مع جدول Chromosome
        return $this->belongsTo(Chromosome::class, 'best_chromosome_id', 'chromosome_id');
    }
}
--------------------------------------------------------------------------------------------------------
app\Models\SelectionType.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SelectionType extends Model
{
    use HasFactory;

    // اسم الجدول في قاعدة البيانات
    // protected $table = 'selection_types';
    protected $primaryKey = 'selection_type_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = ['name', 'description', 'is_active'];

    public function populations()
    {
        // علاقة "واحد إلى متعدد" مع جدول populations
        return $this->hasMany(Population::class, 'selection_id', 'selection_type_id');
    }
}
--------------------------------------------------------------------------------------------------------
