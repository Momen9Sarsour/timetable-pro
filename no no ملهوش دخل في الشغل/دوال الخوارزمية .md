

__construct() 
  --> run()
      --> loadAndPrepareData()
          --> buildConsecutiveTimeslotsMap()
          --> buildStudentGroupMap()
          --> generateLectureBlocksAndAssignInstructors()
              --> getLeastLoadedInstructorForSubject()
              --> splitAndAssignBlocks()
      --> createInitialPopulation()
          --> generateGenesForChromosome()
              --> findOptimalSlotForBlock()
                  --> getPossibleStartSlots()
                  --> countConflictsForSlots()
              --> updateResourceCache()
      --> evaluateFitness()
      --> (حلقة أجيال)
          --> selectParents()
          --> createNewGeneration()
              --> performCrossover()
              --> performMutation()
                  --> isGeneConflictingWithRest()
              --> saveChildChromosome()
      --> تحديث أفضل كروموسوم وإنهاء التشغيل
//////////////////////////////////////////////////////////////////////////////

__construct()
  • تهيئة الكائن: استقبال الإعدادات + سجل Population الرئيسي (run) + Log للتهيئة.

--> run()
  • الدالة الرئيسية: تنفّذ دورة الخوارزمية (GA) كاملة من البداية للنهاية.
  
    --> loadAndPrepareData()
        • تحميل الداتا (sections, instructors, rooms, timeslots).
        • تجهيز الخرائط (مجاميع الطلاب، الأساتذة، البلوكات، ...).

        --> buildConsecutiveTimeslotsMap()
            • بناء خريطة الساعات المتتالية لكل يوم (عشان نقدر نعمل بلوكات متصلة).
        
        --> buildStudentGroupMap()
            • توزيع الطلاب لمجاميع نظرية/عملية بشكل منطقي.
        
        --> generateLectureBlocksAndAssignInstructors()
            • توليد البلوكات (lecture blocks) لكل مادة + إسناد مدرس.
            
            --> getLeastLoadedInstructorForSubject()
                • اختيار المدرّس الأقل حملًا (load) للمادة.
            
            --> splitAndAssignBlocks()
                • تقسيم الساعات المطلوبة لبلوكات مناسبة (theory/practical).

    --> createInitialPopulation()
        • إنشاء الجيل الأول (chromosomes) وربطه مع population_id.
        
        --> generateGenesForChromosome()
            • إنشاء الجينات الخاصة بكل كروموسوم (محاضرات + قاعات + أوقات).
            
            --> findOptimalSlotForBlock()
                • اختيار أفضل أوقات (timeslots) متاحة للبلوك بدون تضارب.
                
                --> getPossibleStartSlots()
                    • جلب قائمة الأوقات المحتملة كبداية للبلوك.
                
                --> countConflictsForSlots()
                    • حساب عدد التعارضات لو حطينا الجين في هذه الأوقات.
            
            --> updateResourceCache()
                • تحديث كاش الموارد المستخدمة (مدرسين، قاعات، مجموعات).

    --> evaluateFitness()
        • تقييم كل كروموسوم وحساب قيمة العقوبة (penalty value) بناءً على التعارضات والقيود.

    --> (حلقة الأجيال - while loop)
        • تكرار عملية التحسين حتى max_generations أو الوصول لحل مثالي.
        
        --> selectParents()
            • اختيار الآباء (parents) بالتورنمنت selection.
        
        --> createNewGeneration()
            • إنشاء جيل جديد من الأطفال (chromosomes) عبر crossover + mutation.
            
            --> performCrossover()
                • دمج جينات الأب والأم لتكوين أطفال.
            
            --> performMutation()
                • تعديل جين عشوائي (room/timeslot) لمنع الركود.
                
                --> isGeneConflictingWithRest()
                    • فحص الجين المعدل إذا يسبب تعارض مع باقي الجينات.
            
            --> saveChildChromosome()
                • حفظ الكروموسوم الجديد (مع جيناته) في قاعدة البيانات.

    --> تحديث أفضل كروموسوم وإنهاء التشغيل
        • اختيار أفضل كروموسوم من آخر جيل وتحديث حالة Population كـ "completed".
//////////////////////////////////////////////////////////////////////////////////////////
وهي الكود الي شغال 

namespace App\Services;

use App\Models\Population;
use Illuminate\Support\Str;
use App\Models\Chromosome;
use App\Models\Gene;
use App\Models\Section;
use App\Models\Instructor;
use App\Models\Room;
use App\Models\Timeslot;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Exception;

class GeneticAlgorithmService
{
    // --- خصائص لتخزين الإعدادات والبيانات ---
    private array $settings;
    private Population $populationRun;
    private Collection $instructors;
    private Collection $theoryRooms;
    private Collection $practicalRooms;
    private Collection $timeslots;
    private Collection $lectureBlocksToSchedule;
    private array $consecutiveTimeslotsMap = [];
    private array $studentGroupMap = [];
    private array $instructorAssignmentMap = [];
    private array $resourceUsageCache = [];

    /**
     * المُنشئ (Constructor)
     * يقوم بتهيئة الخدمة بالإعدادات وسجل التشغيل.
     */
    public function __construct(array $settings, Population $populationRun)
    {
        $this->settings = $settings;
        $this->populationRun = $populationRun;
        Log::info("GA Service initialized for Run ID: {$this->populationRun->population_id}");
    }

    /**
     * الدالة الرئيسية (run)
     * تدير عملية التوليد بأكملها من البداية إلى النهاية.
     */
    public function run()
    {
        try {
            $this->populationRun->update(['status' => 'running', 'start_time' => now()]);
            $this->loadAndPrepareData();

            $currentGenerationNumber = 1;
            // **(تصحيح)**: تمرير populationRun للدالة
            $currentPopulation = $this->createInitialPopulation($currentGenerationNumber, $this->populationRun);
            $this->evaluateFitness($currentPopulation);
            Log::info("Generation #{$currentGenerationNumber} fitness evaluated.");

            $maxGenerations = $this->settings['max_generations'];
            while ($currentGenerationNumber < $maxGenerations) {
                $bestInGen = $currentPopulation->sortBy('penalty_value')->first();
                if ($bestInGen && $bestInGen->penalty_value == 0 && ($this->settings['stop_at_first_valid'] ?? false)) {
                    Log::info("Optimal solution found in Generation #{$currentGenerationNumber}. Stopping.");
                    break;
                }

                $parents = $this->selectParents($currentPopulation);
                $currentGenerationNumber++;
                // **(تصحيح)**: تمرير populationRun للدالة
                $currentPopulation = $this->createNewGeneration($parents, $currentGenerationNumber, $this->populationRun);
                $this->evaluateFitness($currentPopulation);
                Log::info("Generation #{$currentGenerationNumber} fitness evaluated.");
            }

            $finalBest = Chromosome::where('population_id', $this->populationRun->population_id)->orderBy('penalty_value', 'asc')->first();
            $this->populationRun->update([
                'status' => 'completed',
                'end_time' => now(),
                'best_chromosome_id' => $finalBest ? $finalBest->chromosome_id : null
            ]);
            Log::info("GA Run ID: {$this->populationRun->population_id} completed successfully.");
        } catch (Exception $e) {
            Log::error("GA Run failed: " . $e->getMessage() . " at " . $e->getFile() . ":" . $e->getLine() . "\n" . $e->getTraceAsString());
            $this->populationRun->update(['status' => 'failed']);
            throw $e;
        }
    }

    //======================================================================
    // المرحلة الأولى: تحميل وتحضير البيانات
    //======================================================================

    private function loadAndPrepareData()
    {
        Log::info("Loading data for context -> Year: {$this->settings['academic_year']}, Semester: {$this->settings['semester']}");

        // **(حل مشكلة العلاقة)**: استدعاء العلاقات بشكل آمن وبسيط
        $sections = Section::with(['planSubject.subject', 'instructors'])
            ->where('academic_year', $this->settings['academic_year'])
            ->where('semester', $this->settings['semester'])
            ->get();

        if ($sections->isEmpty()) throw new Exception("No sections found for the selected context.");

        $this->instructors = Instructor::with('subjects')->get();
        $this->theoryRooms = Room::whereHas('roomType', fn($q) => $q->where('room_type_name', 'not like', '%Lab%')->where('room_type_name', 'not like', '%مختبر%'))->get();
        $this->practicalRooms = Room::whereHas('roomType', fn($q) => $q->where('room_type_name', 'like', '%Lab%')->orWhere('room_type_name', 'like', '%مختبر%'))->get();
        $this->timeslots = Timeslot::orderByRaw("FIELD(day, 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday')")->orderBy('start_time')->get();

        $this->buildConsecutiveTimeslotsMap();
        $this->buildStudentGroupMap($sections);
        $this->generateLectureBlocksAndAssignInstructors($sections);

        if ($this->lectureBlocksToSchedule->isEmpty()) throw new Exception("No lecture blocks to schedule were found after processing credit hours.");
        Log::info("Data loaded: " . $this->lectureBlocksToSchedule->count() . " lecture blocks will be scheduled.");
    }

    private function generateLectureBlocksAndAssignInstructors(Collection $sections)
    {
        $this->lectureBlocksToSchedule = collect();
        $this->instructorAssignmentMap = [];
        $instructorLoad = $this->instructors->mapWithKeys(fn($inst) => [$inst->id => 0])->toArray();

        $sectionsBySubject = $sections->groupBy('planSubject.subject.id');

        foreach ($sectionsBySubject as $subjectId => $subjectSections) {
            $firstSection = $subjectSections->first();
            $subject = optional(optional($firstSection)->planSubject)->subject;
            if (!$subject) continue;

            $assignedInstructor = $this->getLeastLoadedInstructorForSubject($subject, $instructorLoad);

            if ($subject->theoretical_hours > 0) {
                $theorySection = $subjectSections->firstWhere('activity_type', 'Theory');
                if ($theorySection) {
                    $totalTheorySlots = $subject->theoretical_hours * ($this->settings['theory_credit_to_slots'] ?? 1);
                    $this->splitAndAssignBlocks($theorySection, 'theory', $totalTheorySlots, $assignedInstructor, $instructorLoad);
                }
            }
            if ($subject->practical_hours > 0) {
                $practicalSections = $subjectSections->where('activity_type', 'Practical');
                foreach ($practicalSections as $practicalSection) {
                    $totalPracticalSlots = $subject->practical_hours * ($this->settings['practical_credit_to_slots'] ?? 1);
                    $this->splitAndAssignBlocks($practicalSection, 'practical', $totalPracticalSlots, $assignedInstructor, $instructorLoad);
                }
            }
        }
    }

    private function splitAndAssignBlocks(Section $section, string $type, int $totalSlots, Instructor $instructor, array &$instructorLoad)
    {
        $remainingSlots = $totalSlots;
        $blockCounter = 1;
        $strategy = ($type == 'theory') ? [2, 1] : [4, 3, 2, 1];

        while ($remainingSlots > 0) {
            $blockSlots = 0;
            foreach ($strategy as $size) {
                if ($remainingSlots >= $size) {
                    $blockSlots = $size;
                    break;
                }
            }
            if ($blockSlots == 0) $blockSlots = $remainingSlots;

            $uniqueId = "{$section->id}-{$type}-block{$blockCounter}";
            $this->lectureBlocksToSchedule->push((object)[
                'section' => $section,
                'block_type' => $type,
                'slots_needed' => $blockSlots,
                'block_duration' => $blockSlots * 50,
                'unique_id' => $uniqueId
            ]);
            $this->instructorAssignmentMap[$uniqueId] = $instructor->id;
            $instructorLoad[$instructor->id] += $blockSlots;

            $remainingSlots -= $blockSlots;
            $blockCounter++;
        }
    }

    private function getLeastLoadedInstructorForSubject(\App\Models\Subject $subject, array $instructorLoad)
    {
        $suitableInstructors = $this->instructors->filter(fn($inst) => $inst->subjects->contains($subject->id));
        if ($suitableInstructors->isEmpty()) return $this->instructors->random();

        return $suitableInstructors->sortBy(fn($inst) => $instructorLoad[$inst->id] ?? 0)->first();
    }

    private function buildStudentGroupMap(Collection $sections)
    {
        $this->studentGroupMap = [];
        $sectionsByContext = $sections->groupBy(function ($section) {
            $ps = $section->planSubject;
            return implode('-', [$ps->plan_id, $ps->plan_level, $ps->plan_semester, $section->academic_year, $section->branch ?? 'default']);
        });

        foreach ($sectionsByContext as $sectionsInContext) {
            $maxPracticalSections = $sectionsInContext->where('activity_type', 'Practical')->groupBy('plan_subject_id')->map->count()->max() ?? 0;
            $numberOfStudentGroups = $maxPracticalSections > 0 ? $maxPracticalSections : 1;

            for ($groupIndex = 1; $groupIndex <= $numberOfStudentGroups; $groupIndex++) {
                $theorySections = $sectionsInContext->where('activity_type', 'Theory');
                foreach ($theorySections as $theorySection) {
                    $this->studentGroupMap[$theorySection->id][] = $groupIndex;
                }

                $practicalSectionsBySubject = $sectionsInContext->where('activity_type', 'Practical')->groupBy('plan_subject_id');
                foreach ($practicalSectionsBySubject as $sectionsForOneSubject) {
                    $sortedSections = $sectionsForOneSubject->sortBy('section_number')->values();
                    if ($sortedSections->has($groupIndex - 1)) {
                        $practicalSectionForThisGroup = $sortedSections->get($groupIndex - 1);
                        $this->studentGroupMap[$practicalSectionForThisGroup->id][] = $groupIndex;
                    }
                }
            }
        }
    }

    private function buildConsecutiveTimeslotsMap()
    {
        $timeslotsByDay = $this->timeslots->groupBy('day');
        $this->consecutiveTimeslotsMap = [];
        foreach ($timeslotsByDay as $dayTimeslots) {
            $dayTimeslotsValues = $dayTimeslots->values();
            for ($i = 0; $i < $dayTimeslotsValues->count(); $i++) {
                $currentSlot = $dayTimeslotsValues[$i];
                $this->consecutiveTimeslotsMap[$currentSlot->id] = [];
                for ($j = $i + 1; $j < $dayTimeslotsValues->count(); $j++) {
                    $nextSlot = $dayTimeslotsValues[$j];
                    if ($nextSlot->start_time == $currentSlot->end_time) {
                        $this->consecutiveTimeslotsMap[$currentSlot->id][] = $nextSlot->id;
                        $currentSlot = $nextSlot;
                    } else {
                        break;
                    }
                }
            }
        }
    }

    //======================================================================
    // المرحلة الثانية: إنشاء الجيل الأول
    //======================================================================

    private function createInitialPopulation(int $generationNumber, Population $populationRun): Collection
    {
        Log::info("Creating intelligent initial population (Generation #{$generationNumber})");

        $createdChromosomes = collect();
        for ($i = 0; $i < $this->settings['population_size']; $i++) {
            $chromosome = Chromosome::create([
                'population_id' => $populationRun->population_id,
                'penalty_value' => -1,
                'generation_number' => $generationNumber
            ]);
            $this->generateGenesForChromosome($chromosome);
            $createdChromosomes->push($chromosome);
        }

        return $createdChromosomes;
    }

    private function generateGenesForChromosome(Chromosome $chromosome)
    {
        $this->resourceUsageCache = [];
        $genesToInsert = [];

        foreach ($this->lectureBlocksToSchedule as $lectureBlock) {
            $instructorId = $this->instructorAssignmentMap[$lectureBlock->unique_id];
            $room = $this->getRandomRoomForBlock($lectureBlock);
            $studentGroupIds = $this->studentGroupMap[$lectureBlock->section->id] ?? [];

            $foundSlots = $this->findOptimalSlotForBlock($lectureBlock, $instructorId, $room->id, $studentGroupIds);
            $this->updateResourceCache($foundSlots, $instructorId, $room->id, $studentGroupIds);

            // بما أننا سنستخدم حقل JSON، ننشئ جيناً واحداً فقط
            $genesToInsert[] = [
                'chromosome_id' => $chromosome->chromosome_id,
                'lecture_unique_id' => $lectureBlock->unique_id,
                'section_id' => $lectureBlock->section->id,
                'instructor_id' => $instructorId,
                'room_id' => $room->id,
                'timeslot_ids' => json_encode($foundSlots),
                'student_group_id' => json_encode($studentGroupIds),
                'block_type' => $lectureBlock->block_type,
                'block_duration' => $lectureBlock->block_duration,
            ];
        }

        if (!empty($genesToInsert)) {
            Gene::insert($genesToInsert);
        }
    }

    private function findOptimalSlotForBlock($lectureBlock, int $instructorId, int $roomId, array $studentGroupIds): array
    {
        $possibleStartSlots = $this->getPossibleStartSlots($lectureBlock->slots_needed);

        $shuffledSlots = $possibleStartSlots->shuffle();
        foreach ($shuffledSlots as $trialSlots) {
            if ($this->countConflictsForSlots($trialSlots, $instructorId, $roomId, $studentGroupIds) == 0) {
                return $trialSlots;
            }
        }

        return $possibleStartSlots->isNotEmpty() ? $possibleStartSlots->random() : $this->findRandomConsecutiveTimeslots($lectureBlock->slots_needed);
    }

    private function countConflictsForSlots(array $slotIds, ?int $instructorId, ?int $roomId, ?array $studentGroupIds): int
    {
        $conflicts = 0;
        foreach ($slotIds as $slotId) {
            if (isset($this->resourceUsageCache[$slotId])) {
                if ($studentGroupIds) {
                    foreach ($studentGroupIds as $groupId) {
                        if (isset($this->resourceUsageCache[$slotId]['student_groups'][$groupId])) $conflicts++;
                    }
                }
                if ($instructorId && isset($this->resourceUsageCache[$slotId]['instructors'][$instructorId])) $conflicts++;
                if ($roomId && isset($this->resourceUsageCache[$slotId]['rooms'][$roomId])) $conflicts++;
            }
        }
        return $conflicts;
    }

    private function updateResourceCache(array $slotIds, int $instructorId, int $roomId, ?array $studentGroupIds): void
    {
        foreach ($slotIds as $slotId) {
            $this->resourceUsageCache[$slotId]['instructors'][$instructorId] = true;
            $this->resourceUsageCache[$slotId]['rooms'][$roomId] = true;
            if ($studentGroupIds) {
                foreach ($studentGroupIds as $groupId) {
                    $this->resourceUsageCache[$slotId]['student_groups'][$groupId] = true;
                }
            }
        }
    }

    //======================================================================
    // المرحلة الثالثة: التقييم والتحسين
    //======================================================================

    private function evaluateFitness(Collection $chromosomes)
    {
        DB::transaction(function () use ($chromosomes) {
            foreach ($chromosomes as $chromosome) {
                $genes = $chromosome->genes()->with(['section.planSubject.subject', 'room.roomType', 'instructor'])->get();
                $totalPenalty = 0;
                $resourceUsageMap = [];

                foreach ($genes as $gene) {
                    $timeslotIds = $gene->timeslot_ids ?? [];
                    $studentGroupIds = $gene->student_group_id ?? [];

                    // --- التحقق من التعارضات الصارمة ---
                    foreach ($timeslotIds as $timeslotId) {
                        if ($studentGroupIds) {
                            foreach ($studentGroupIds as $groupId) {
                                if (isset($resourceUsageMap[$timeslotId]['student_groups'][$groupId])) $totalPenalty += 2000;
                                $resourceUsageMap[$timeslotId]['student_groups'][$groupId] = true;
                            }
                        }
                        if (isset($resourceUsageMap[$timeslotId]['instructors'][$gene->instructor_id])) $totalPenalty += 1000;
                        $resourceUsageMap[$timeslotId]['instructors'][$gene->instructor_id] = true;

                        if (isset($resourceUsageMap[$timeslotId]['rooms'][$gene->room_id])) $totalPenalty += 800;
                        $resourceUsageMap[$timeslotId]['rooms'][$gene->room_id] = true;
                    }

                    // --- التحقق من القيود المرنة ---
                    if (!$gene->room || !$gene->section || !optional($gene->section)->planSubject) continue;
                    $subject = $gene->section->planSubject->subject;
                    $isPracticalBlock = Str::contains($gene->lecture_unique_id, 'practical');
                    $isPracticalRoom = Str::contains(strtolower(optional($gene->room->roomType)->room_type_name), ['lab', 'مختبر']);

                    if ($isPracticalBlock && !$isPracticalRoom) $totalPenalty += 600;
                    if (!$isPracticalBlock && $isPracticalRoom) $totalPenalty += 300;
                    if ($gene->section->student_count > $gene->room->room_size) $totalPenalty += 500;
                }

                $chromosome->penalty_value = $totalPenalty;
                Chromosome::where('chromosome_id', $chromosome->chromosome_id)->update(['penalty_value' => $totalPenalty]);
            }
        });
    }

    private function selectParents(Collection $population): array
    {
        $parents = [];
        $tournamentSize = 3;
        $populationCount = $population->count();

        for ($i = 0; $i < $this->settings['population_size']; $i++) {
            if ($populationCount == 0) break;
            $participants = $population->random(min($tournamentSize, $populationCount));
            $parents[] = $participants->sortBy('penalty_value')->first();
        }
        return $parents;
    }

    private function createNewGeneration(array $parents, int $nextGenerationNumber, Population $populationRun): Collection
    {
        Log::info("Creating new generation #{$nextGenerationNumber}");
        $childrenData = [];
        $parentPool = array_filter($parents);

        if (empty($parentPool)) {
            Log::warning("Parent pool is empty for generation {$nextGenerationNumber}. Cannot create new generation.");
            return collect();
        }

        for ($i = 0; $i < $this->settings['population_size']; $i += 2) {
            if (count($parentPool) < 2) {
                if (empty($parents)) break;
                $parentPool = array_filter($parents);
            }

            $p1_key = array_rand($parentPool);
            $parent1 = $parentPool[$p1_key];
            unset($parentPool[$p1_key]);
            $p2_key = array_rand($parentPool);
            $parent2 = $parentPool[$p2_key];
            unset($parentPool[$p2_key]);

            if (!$parent1 || !$parent2) continue;

            [$child1Genes, $child2Genes] = $this->performCrossover($parent1, $parent2);
            $childrenData[] = $this->performMutation($child1Genes);
            if (count($childrenData) < $this->settings['population_size']) {
                $childrenData[] = $this->performMutation($child2Genes);
            }
        }

        $newlyCreatedChromosomes = [];
        foreach ($childrenData as $genesToInsert) {
            if (!empty($genesToInsert)) {
                $newlyCreatedChromosomes[] = $this->saveChildChromosome($genesToInsert, $nextGenerationNumber, $populationRun);
            }
        }
        return collect($newlyCreatedChromosomes);
    }

    private function performCrossover(Chromosome $parent1, Chromosome $parent2): array
    {
        $p1Genes = $parent1->genes()->get()->keyBy('lecture_unique_id');
        $p2Genes = $parent2->genes()->get()->keyBy('lecture_unique_id');
        $child1Genes = [];
        $child2Genes = [];

        $crossoverPoint = rand(1, $this->lectureBlocksToSchedule->count() - 1);
        $currentIndex = 0;

        foreach ($this->lectureBlocksToSchedule as $lectureBlock) {
            $sourceForChild1 = ($currentIndex < $crossoverPoint) ? $p1Genes : $p2Genes;
            $sourceForChild2 = ($currentIndex < $crossoverPoint) ? $p2Genes : $p1Genes;

            $child1Genes[] = $sourceForChild1->get($lectureBlock->unique_id) ?? $p2Genes->get($lectureBlock->unique_id);
            $child2Genes[] = $sourceForChild2->get($lectureBlock->unique_id) ?? $p1Genes->get($lectureBlock->unique_id);

            $currentIndex++;
        }
        return [array_filter($child1Genes), array_filter($child2Genes)];
    }

    private function performMutation(array $genes): array
    {
        if (lcg_value() < $this->settings['mutation_rate'] && !empty($genes)) {
            $geneIndexToMutate = array_rand($genes);
            $geneToMutate = $genes[$geneIndexToMutate];

            $lectureBlock = $this->lectureBlocksToSchedule->firstWhere('unique_id', $geneToMutate->lecture_unique_id);
            if (!$lectureBlock) return $genes;

            $newRoom = $this->getRandomRoomForBlock($lectureBlock);
            $newTimeslots = $this->findRandomConsecutiveTimeslots($lectureBlock->slots_needed);

            $tempGene = clone $geneToMutate;
            $tempGene->room_id = $newRoom->id;
            if (!$this->isGeneConflictingWithRest($tempGene, $genes)) {
                $genes[$geneIndexToMutate] = $tempGene;
                return $genes;
            }

            $tempGene = clone $geneToMutate;
            $tempGene->timeslot_ids = $newTimeslots;
            if (!$this->isGeneConflictingWithRest($tempGene, $genes)) {
                $genes[$geneIndexToMutate] = $tempGene;
                return $genes;
            }

            $geneToMutate->room_id = $newRoom->id;
            $geneToMutate->timeslot_ids = $newTimeslots;
            $genes[$geneIndexToMutate] = $geneToMutate;
        }
        return $genes;
    }

    private function isGeneConflictingWithRest(Gene $targetGene, array $allOtherGenes): bool
    {
        $otherGenes = array_filter($allOtherGenes, fn($g) => $g && $g->lecture_unique_id != $targetGene->lecture_unique_id);
        $studentGroupIds = $targetGene->student_group_id ?? [];

        foreach ($targetGene->timeslot_ids as $timeslotId) {
            foreach ($otherGenes as $otherGene) {
                if (in_array($timeslotId, $otherGene->timeslot_ids)) {
                    if ($otherGene->instructor_id == $targetGene->instructor_id) return true;
                    if ($otherGene->room_id == $targetGene->room_id) return true;

                    $otherStudentGroupIds = $otherGene->student_group_id ?? [];
                    if (!empty($studentGroupIds) && !empty($otherStudentGroupIds) && count(array_intersect($studentGroupIds, $otherStudentGroupIds)) > 0) return true;
                }
            }
        }
        return false;
    }

    private function saveChildChromosome(array $genes, int $generationNumber, Population $populationRun): Chromosome
    {
        $chromosome = Chromosome::create([
            'population_id' => $populationRun->population_id,
            'penalty_value' => -1,
            'generation_number' => $generationNumber
        ]);

        $genesToInsert = [];
        foreach ($genes as $gene) {
            if (is_null($gene)) continue;
            $genesToInsert[] = [
                'chromosome_id' => $chromosome->chromosome_id,
                'lecture_unique_id' => $gene->lecture_unique_id,
                'section_id' => $gene->section_id,
                'instructor_id' => $gene->instructor_id,
                'room_id' => $gene->room_id,
                'timeslot_ids' => is_string($gene->timeslot_ids) ? $gene->timeslot_ids : json_encode($gene->timeslot_ids),
                'student_group_id' => is_string($gene->student_group_id) ? $gene->student_group_id : json_encode($gene->student_group_id),
                'block_type' => $gene->block_type,
                'block_duration' => $gene->block_duration,

            ];
        }
        if (!empty($genesToInsert)) Gene::insert($genesToInsert);
        return $chromosome;
    }

    private function getPossibleStartSlots(int $slotsNeeded): Collection
    {
        if ($slotsNeeded <= 0) return collect();
        return $this->timeslots->filter(function ($slot) use ($slotsNeeded) {
            return isset($this->consecutiveTimeslotsMap[$slot->id]) && (count($this->consecutiveTimeslotsMap[$slot->id]) + 1) >= $slotsNeeded;
        })->mapWithKeys(function ($slot) use ($slotsNeeded) {
            return [$slot->id => array_merge([$slot->id], array_slice($this->consecutiveTimeslotsMap[$slot->id], 0, $slotsNeeded - 1))];
        });
    }

    private function findRandomConsecutiveTimeslots(int $slotsNeeded): array
    {
        if ($slotsNeeded <= 0) return [];
        if ($slotsNeeded == 1) return [$this->timeslots->random()->id];

        $possibleSlots = $this->getPossibleStartSlots($slotsNeeded);
        return $possibleSlots->isNotEmpty() ? $possibleSlots->random() : [$this->timeslots->random()->id];
    }

    private function getRandomRoomForBlock(\stdClass $lectureBlock)
    {
        $section = $lectureBlock->section;
        $roomsSource = ($lectureBlock->block_type === 'practical') ? $this->practicalRooms : $this->theoryRooms;
        if ($roomsSource->isEmpty()) {
            $roomsSource = ($lectureBlock->block_type === 'practical') ? $this->theoryRooms : $this->practicalRooms;
            if ($roomsSource->isEmpty()) return Room::all()->random();
        }

        $suitableRooms = $roomsSource->where('room_size', '>=', $section->student_count);
        return $suitableRooms->isNotEmpty() ? $suitableRooms->random() : $roomsSource->random();
    }
}
