app\Models\Chromosome.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Chromosome extends Model
{
    use HasFactory;

    // اسم الجدول
    // protected $table = 'chromosomes';

    // اسم المفتاح الأساسي
    protected $primaryKey = 'chromosome_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = [
        'population_id',
        'penalty_value',
        'generation_number',
        'is_best_of_generation',

        'student_conflict_penalty',
        'teacher_conflict_penalty',
        'room_conflict_penalty',
        'capacity_conflict_penalty',
        'room_type_conflict_penalty',
        'teacher_eligibility_conflict_penalty',
        'fitness_value',
    ];

    /**
     * علاقة: الكروموسوم الواحد يتبع لعملية تشغيل واحدة (Population).
     */
    public function population()
    {
        // علاقة "واحد إلى واحد" مع جدول Population
        return $this->belongsTo(Population::class, 'population_id', 'population_id');
    }

    /**
     * علاقة: الكروموسوم الواحد يحتوي على عدة جينات (تفاصيل محاضرات).
     */
    public function genes()
    {
        // علاقة "واحد إلى متعدد" مع جدول Gene
        return $this->hasMany(Gene::class, 'chromosome_id', 'chromosome_id');
    }
}
--------------------------------------------------------------------------------------------------------
app\Models\CrossoverType.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class CrossoverType extends Model
{
    use HasFactory;

    // اسم الجدول في قاعدة البيانات
    // protected $table = 'crossovers';
    protected $primaryKey = 'crossover_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = ['name', 'slug', 'description', 'is_active'];

    public function populations()
    {
        // علاقة "واحد إلى متعدد" مع جدول populations
        return $this->hasMany(Population::class, 'crossover_id', 'crossover_id');
    }
}

-------------------------------------------------------------------------------------------------------
app\Models\Department.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Department extends Model
{
    use HasFactory;

    protected $fillable = [
        'department_no',
        'department_name',
    ];

    /**
     * Get the instructors for the department.
     * علاقة: القسم الواحد لديه عدة مدرسين (One To Many)
     */
    public function instructors()
    {
        return $this->hasMany(Instructor::class, 'department_id', 'id');
    }

    /**
     * Get the subjects offered primarily by the department.
     * علاقة: القسم الواحد يقدم عدة مواد (One To Many)
     */
    public function subjects()
    {
        return $this->hasMany(Subject::class, 'department_id', 'id');
    }

    /**
     * Get the academic plans associated with the department.
     * علاقة: القسم الواحد لديه عدة خطط دراسية (One To Many)
     */
    public function plans()
    {
        return $this->hasMany(Plan::class, 'department_id', 'id');
    }

}
------------------------------------------------------------------------------------------------------
app\Models\Gene.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Gene extends Model
{
    use HasFactory;

    // protected $table = 'genes';
    protected $primaryKey = 'gene_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = [
        'chromosome_id',
        'lecture_unique_id',
        'section_id',
        'instructor_id',
        'room_id',
        //'timeslot_id', // هذا يربط بجدول timeslots الأساسي
        'timeslot_ids',
        'block_type', // 'theory' أو 'practical'
        'block_duration', // مدة البلوك بالساعات
        'is_continuous', // هل البلوك متصل أم مقسم
        'student_group_id', // رقم مجموعة الطلاب

    ];

    // **(الأهم)** هذا السطر يحول الـ JSON إلى مصفوفة PHP والعكس تلقائياً
    protected $casts = [
        'timeslot_ids' => 'array',
        'student_group_id' => 'array',
        'is_continuous' => 'boolean',
    ];

    /**
     * علاقة: الجين يتبع لكروموسوم واحد.
     */
    public function chromosome()
    {
        // علاقة "واحد إلى واحد" مع جدول Chromosome
        return $this->belongsTo(Chromosome::class, 'chromosome_id', 'chromosome_id');
    }

    /**
     * علاقة: الجين يمثل شعبة واحدة.
     */
    public function section()
    {
        // علاقة "واحد إلى واحد" مع جدول Section
        return $this->belongsTo(Section::class, 'section_id', 'id');
    }

    /**
     * علاقة: الجين له مدرس واحد.
     */
    public function instructor()
    {
        // علاقة "واحد إلى واحد" مع جدول Instructor
        return $this->belongsTo(Instructor::class, 'instructor_id', 'id');
    }

    /**
     * علاقة: الجين له قاعة واحدة.
     */
    public function room()
    {
        // علاقة "واحد إلى واحد" مع جدول Room
        return $this->belongsTo(Room::class, 'room_id', 'id');
    }

    /**
     * علاقة: الجين له فترة زمنية واحدة (من الجدول الأساسي).
     */
    public function timeslot()
    {
        // علاقة "واحد إلى واحد" مع جدول Timeslot
        return $this->belongsTo(Timeslot::class, 'timeslot_id', 'id');
    }

    public function algorithmTimeslot()
    {
        return $this->hasOne(Timeslot::class, 'gene_id', 'gene_id');
    }
}
-----------------------------------------------------------------------------------------------------
app\Models\GeneratedSchedule.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class GeneratedSchedule extends Model
{
    use HasFactory;

    // اسم الجدول مختلف
    protected $table = 'generated_schedules';

    protected $fillable = [
        'section_id',
        'instructor_id',
        'room_id',
        'timeslot_id',
        'academic_year',
        'semester',
        'lecture_type',
    ];

    /**
     * Get the section associated with this schedule entry.
     * علاقة: إدخال الجدول يتبع لشعبة واحدة (One To Many Inverse)
     */
    public function section()
    {
        return $this->belongsTo(Section::class, 'section_id', 'id');
    }

    /**
     * Get the instructor assigned to this schedule entry.
     * علاقة: إدخال الجدول يتبع لمدرس واحد (One To Many Inverse)
     */
    public function instructor()
    {
        return $this->belongsTo(Instructor::class, 'instructor_id', 'id');
    }

    /**
     * Get the room assigned to this schedule entry.
     * علاقة: إدخال الجدول يتبع لقاعة واحدة (One To Many Inverse)
     */
    public function room()
    {
        return $this->belongsTo(Room::class, 'room_id', 'id');
    }

    /**
     * Get the timeslot for this schedule entry.
     * علاقة: إدخال الجدول يتبع لفترة زمنية واحدة (One To Many Inverse)
     */
    public function timeslot()
    {
        return $this->belongsTo(Timeslot::class, 'timeslot_id', 'id');
    }

     // يمكنك إضافة علاقات للوصول السريع للمادة والخطة واليوم والوقت من هنا
     public function subject() {
         // يجب أن يكون لديك علاقة معرفة في موديل Section للوصول للمادة
         return $this->section->subject(); // قد تحتاج لتحسين الأداء Eager Loading
     }
      public function plan() {
         // يجب أن يكون لديك علاقة معرفة في موديل Section للوصول للخطة
         return $this->section->plan();
     }
     public function dayOfWeek() {
         return $this->timeslot->day_of_week; // أو DayName إذا استخدمت الـ Accessor
     }
     public function startTime() {
         return $this->timeslot->start_time; // أو FormattedStartTime
     }
     public function endTime() {
         return $this->timeslot->end_time; // أو FormattedEndTime
     }
}
-----------------------------------------------------------------------------------------------------------
app\Models\Instructor.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Instructor extends Model
{
    use HasFactory;

    protected $fillable = [
        'user_id', // تأكد من إضافته هنا
        'instructor_no',
        'instructor_name', // قرر إذا كنت ستحتفظ به أم لا
        'academic_degree',
        'department_id',
        'availability_preferences',
        'max_weekly_hours',
        'office_location', // أضفنا هذا
        'office_hours',    // أضفنا هذا
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'availability_preferences' => 'json', // مهم لتحويل حقل JSON لمصفوفة PHP والعكس
    ];

    /**
     * Get the user account associated with the instructor.
     * علاقة: المدرس يتبع لمستخدم واحد (One To One Inverse)
     */
    public function user()
    {
        return $this->belongsTo(User::class, 'user_id', 'id');
    }

    /**
     * Get the department that the instructor belongs to.
     * علاقة: المدرس يتبع لقسم واحد (One To Many Inverse)
     */
    public function department()
    {
        return $this->belongsTo(Department::class, 'department_id', 'id');
    }

    /**
     * Get the schedule entries (lectures) assigned to the instructor.
     * علاقة: المدرس لديه عدة محاضرات في الجدول النهائي (One To Many)
     */
    public function scheduleEntries()
    {
        return $this->hasMany(GeneratedSchedule::class, 'instructor_id', 'id');
    }

    public function subjects()
    {
        // اسم الموديل المرتبط، اسم الجدول الوسيط، المفتاح الأجنبي لهذا الموديل، المفتاح الأجنبي للموديل المرتبط
        return $this->belongsToMany(Subject::class, 'instructor_subject', 'instructor_id', 'subject_id')
            ->withTimestamps(); // إذا أضفت timestamps للجدول الوسيط
    }

    public function sections()
    {
        return $this->belongsToMany(Section::class, 'instructor_section');
    }

    public function canTeach(Subject $subject): bool
    {
        // الطريقة الأكثر كفاءة هي التحقق من وجود العلاقة
        //  exists() تنفذ استعلاماً سريعاً للتحقق من وجود سجل واحد على الأقل يطابق الشرط
        return $this->subjects()->where('subjects.id', $subject->id)->exists();

        // طريقة أخرى (أقل كفاءة إذا لم تكن العلاقة محملة مسبقاً):
        // $assignedSubjectIds = $this->subjects->pluck('id');
        // return $assignedSubjectIds->contains($subject->id);
    }

}
---------------------------------------------------------------------------------------------------------
app\Models\MutationType.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class MutationType extends Model
{
    use HasFactory;

    protected $primaryKey = 'mutation_id';

    protected $fillable = [
        'name',
        'slug',
        'description',
        'is_active',
    ];

    protected $casts = [
        'is_active' => 'boolean',
    ];

}
------------------------------------------------------------------------------------------------------
app\Models\Plan.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Plan extends Model
{
    use HasFactory;

    protected $fillable = [
        'plan_no',
        'plan_name',
        'year',
        'plan_hours',
        'is_active',
        'department_id',
    ];

     /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'is_active' => 'boolean', // تحويل is_active إلى boolean
    ];


    /**
     * Get the department associated with the plan.
     * علاقة: الخطة تتبع لقسم واحد (One To Many Inverse)
     */
    public function department()
    {
        return $this->belongsTo(Department::class, 'department_id', 'id');
    }

    /**
     * Get the subjects included in this plan.
     * علاقة: الخطة تحتوي على عدة مواد (Many To Many through plan_subjects)
     */
    public function subjects()
    {
        return $this->belongsToMany(Subject::class, 'plan_subjects', 'plan_id', 'subject_id')
                    ->withPivot('plan_level', 'plan_semester')
                    ->withTimestamps();
    }

     /**
     * Get the plan_subjects entries for this plan.
     * علاقة: الخطة لها عدة إدخالات في جدول plan_subjects (One To Many)
     */
    public function planSubjectEntries()
    {
        return $this->hasMany(PlanSubject::class, 'plan_id', 'id');
    }

    /**
     * Get the expected student counts for this plan.
     * علاقة: الخطة لها عدة سجلات أعداد متوقعة (One To Many)
     */
    public function expectedCounts()
    {
        return $this->hasMany(PlanExpectedCount::class, 'plan_id', 'id');
    }
}
--------------------------------------------------------------------------------------------------------
app\Models\PlanExpectedCount.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class PlanExpectedCount extends Model
{
    use HasFactory;

    protected $table = 'plan_expected_counts';

    protected $fillable = [
        'plan_id',
        'plan_level',
        'plan_semester',
        'male_count',
        'female_count',
        'branch',
        'academic_year',
    ];

    /**
     * Get the plan associated with this count.
     */
    public function plan()
    {
        return $this->belongsTo(Plan::class, 'plan_id', 'id');
    }
}
--------------------------------------------------------------------------------------------------------
app\Models\PlanGroup.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class PlanGroup extends Model
{
    use HasFactory;

    // تحديد اسم الجدول
    // protected $table = 'plan_groups';

    // تحديد Primary Key
    protected $primaryKey = 'group_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = [
        'plan_id',
        'plan_level',
        'academic_year',
        'semester',
        'branch',
        'section_id',
        'group_no',
        'group_size',
        'gender',
    ];

    // تحويل البيانات للأنواع المناسبة
    protected $casts = [
        'plan_level' => 'integer',
        'academic_year' => 'integer',
        'semester' => 'integer',
        'group_no' => 'integer',
        'group_size' => 'integer',
    ];

    /**
     * علاقة: المجموعة تنتمي لخطة واحدة
     */
    public function plan()
    {
        return $this->belongsTo(Plan::class, 'plan_id', 'id');
    }

    /**
     * علاقة: المجموعة تنتمي لشعبة واحدة
     */
    public function section()
    {
        return $this->belongsTo(Section::class, 'section_id', 'id');
    }

    /**
     * علاقة: المجموعة مرتبطة بقسم من خلال الخطة
     */
    public function department()
    {
        return $this->hasOneThrough(
            Department::class,
            Plan::class,
            'id', // Foreign key على جدول plans
            'id', // Foreign key على جدول departments
            'plan_id', // Local key على plan_groups
            'department_id' // Local key على plans
        );
    }

    /**
     * Scope: البحث حسب السياق الكامل
     */
    public function scopeByContext($query, $planId, $planLevel, $academicYear, $semester, $branch = null)
    {
        return $query->where('plan_id', $planId)
                    ->where('plan_level', $planLevel)
                    ->where('academic_year', $academicYear)
                    ->where('semester', $semester)
                    ->where('branch', $branch);
    }

    /**
     * Scope: البحث حسب الشعبة
     */
    public function scopeBySectionId($query, $sectionId)
    {
        return $query->where('section_id', $sectionId);
    }

    /**
     * Scope: البحث حسب رقم المجموعة
     */
    public function scopeByGroupNumber($query, $groupNo)
    {
        return $query->where('group_no', $groupNo);
    }

    /**
     * Scope: البحث حسب نشاط الشعبة (نظري/عملي)
     */
    public function scopeByActivityType($query, $activityType)
    {
        return $query->whereHas('section', function ($q) use ($activityType) {
            $q->where('activity_type', $activityType);
        });
    }

    /**
     * Accessor: الحصول على معرف السياق الفريد
     */
    public function getContextIdentifierAttribute()
    {
        return implode('-', [
            $this->plan_id,
            $this->plan_level,
            $this->plan_semester ?? $this->semester,
            $this->academic_year,
            $this->branch ?? 'default'
        ]);
    }

    /**
     * دالة لجلب كل المجموعات في سياق معين
     */
    public static function getGroupsForContext($planId, $planLevel, $academicYear, $semester, $branch = null)
    {
        return static::byContext($planId, $planLevel, $academicYear, $semester, $branch)
                    ->with(['section.planSubject.subject'])
                    ->orderBy('group_no')
                    ->get();
    }

    /**
     * دالة لجلب المجموعات لشعبة معينة
     */
    public static function getGroupsForSection($sectionId)
    {
        return static::bySectionId($sectionId)
                    ->orderBy('group_no')
                    ->get();
    }

    /**
     * دالة للحصول على أرقام المجموعات لشعبة معينة (للاستخدام في الخوارزمية)
     */
    public static function getGroupNumbersForSection($sectionId)
    {
        return static::bySectionId($sectionId)
                    ->pluck('group_no')
                    ->toArray();
    }

    /**
     * دالة لحذف كل مجموعات سياق معين
     */
    public static function clearContextGroups($planId, $planLevel, $academicYear, $semester, $branch = null)
    {
        return static::byContext($planId, $planLevel, $academicYear, $semester, $branch)->delete();
    }

    /**
     * دالة لحذف مجموعات شعبة معينة
     */
    public static function clearSectionGroups($sectionId)
    {
        return static::bySectionId($sectionId)->delete();
    }
}
-------------------------------------------------------------------------------------------------------
app\Models\PlanSubject.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class PlanSubject extends Model
{
    use HasFactory;

    protected $table = 'plan_subjects'; // تحديد اسم الجدول

    protected $fillable = [
        'plan_id',
        'subject_id',
        'plan_level',
        'plan_semester',
    ];

    // لا تحتاج timestamps إذا لم تضفها في الـ migration لجدول plan_subjects
    // public $timestamps = true;

    /**
     * Get the plan associated with this entry.
     */
    public function plan()
    {
        return $this->belongsTo(Plan::class, 'plan_id', 'id');
    }

    /**
     * Get the subject associated with this entry.
     */
    public function subject()
    {
        return $this->belongsTo(Subject::class, 'subject_id', 'id');
    }

     /**
     * Get the sections defined for this specific plan subject entry.
     * علاقة: مدخل خطة المادة الواحد قد يكون له عدة شعب (One To Many)
     */
    public function sections()
    {
        return $this->hasMany(Section::class, 'plan_subject_id', 'id');
    }

}
------------------------------------------------------------------------------------------------------
app\Models\Population.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Population extends Model
{
    use HasFactory;

    // اسم الجدول
    // protected $table = 'populations';
    protected $primaryKey = 'population_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = [
        'parent_id',
        'academic_year',
        'semester',
        'theory_credit_to_slots',
        'practical_credit_to_slots',
        'population_size',
        'crossover_id',
        'selection_id',
        'mutation_rate',
        'max_generations',
        'elitism_count', // عدد الكروموسومات الصفوة (رقم)
        'elite_chromosome_ids', // IDs الصفوة الحالية (مصفوفة)
        'crossover_rate',
        'mutation_id',
        'selection_size',
        'stop_at_first_valid',
        'status',
        'start_time',
        'end_time',
        'best_chromosome_id',
    ];

    protected $casts = [
        'elite_chromosome_ids' => 'array',
    ];

    /**
     * علاقة: عملية التشغيل الواحدة تتبع لنوع اختيار واحد.
     */
    public function selectionType()
    {
        // علاقة "واحد إلى واحد" مع جدول SelectionType
        return $this->belongsTo(SelectionType::class, 'selection_id', 'selection_type_id');
    }

    /**
     * علاقة: عملية التشغيل الواحدة تتبع لنوع تزاوج واحد.
     */
    public function crossover()
    {
        // علاقة "واحد إلى واحد" مع جدول CrossoverType
        return $this->belongsTo(CrossoverType::class, 'crossover_id', 'crossover_id');
    }

    /**
     * علاقة: عملية التشغيل الواحدة تحتوي على عدة كروموسومات (حلول مقترحة).
     */
    public function chromosomes()
    {
        // علاقة "واحد إلى متعدد" مع جدول Chromosome
        return $this->hasMany(Chromosome::class, 'population_id', 'population_id');
    }

    /**
     * علاقة: عملية التشغيل الواحدة لها أفضل كروموسوم واحد في النهاية.
     */
    public function bestChromosome()
    {
        // علاقة "واحد إلى واحد" مع جدول Chromosome
        return $this->belongsTo(Chromosome::class, 'best_chromosome_id', 'chromosome_id');
    }

    public function mutationType()
    {
        return $this->belongsTo(MutationType::class, 'mutation_id', 'mutation_id');
    }

    /**
     * علاقة: Population الأب (إذا كان هذا Population مشتق من آخر)
     */
    public function parent()
    {
        return $this->belongsTo(Population::class, 'parent_id', 'population_id');
    }

    /**
     * علاقة: Population الأطفال (الأجيال المشتقة من هذا Population)
     */
    public function children()
    {
        return $this->hasMany(Population::class, 'parent_id', 'population_id');
    }

    /**
     * تحقق إذا كان هذا Population هو الجيل الأول (ليس له أب)
     */
    public function isInitialGeneration()
    {
        return is_null($this->parent_id);
    }

    /**
     * تحقق إذا كان هذا Population له أطفال (أجيال مشتقة)
     */
    public function hasChildren()
    {
        return $this->children()->exists();
    }
}
----------------------------------------------------------------------------------------------------
app\Models\Role.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Role extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'id',
        'display_name',
        'description',
    ];

    /**
     * Get the users that have this role.
     * علاقة: الدور الواحد يمتلكه عدة مستخدمين (One To Many)
     */

    public function users()
    {
        // اسم الموديل المرتبط، المفتاح الأجنبي في جدول users، المفتاح المحلي في جدول roles
        return $this->hasMany(User::class, 'role_id', 'id');
    }
}
-----------------------------------------------------------------------------------------------------------
app\Models\Room.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Room extends Model
{
    use HasFactory;

    protected $fillable = [
        'room_no',
        'room_name',
        'room_size',
        'room_gender',
        'room_branch',
        'room_type_id',
        // 'equipment', // أضفنا هذا
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'equipment' => 'json', // مهم لحقل JSON
    ];

    /**
     * Get the type of the room.
     */
    public function roomType()
    {
        return $this->belongsTo(RoomType::class, 'room_type_id', 'id');
    }

    /**
     * Get the schedule entries (lectures) assigned to this room.
     */
    public function scheduleEntries()
    {
        return $this->hasMany(GeneratedSchedule::class, 'room_id', 'id');
    }
}
-------------------------------------------------------------------------------------------------------
app\Models\RoomType.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class RoomType extends Model
{
    use HasFactory;

    // اسم الجدول مختلف
    protected $table = 'rooms_types';

    protected $fillable = [
        'room_type_name',
    ];

    /**
     * Get the rooms of this type.
     * علاقة: النوع الواحد لديه عدة قاعات (One To Many)
     */
    public function rooms()
    {
        return $this->hasMany(Room::class, 'room_type_id', 'id');
    }
}
-----------------------------------------------------------------------------------------------------
app\Models\Section.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Section extends Model
{
    use HasFactory;

    protected $fillable = [
        'plan_subject_id',
        'section_number',
        'student_count',
        'section_gender',
        'branch',
        'academic_year',
        'semester',
        'activity_type',
    ];

    /**
     * Get the plan subject entry associated with this section.
     * علاقة: الشعبة تتبع لمدخل خطة مادة واحد (One To Many Inverse)
     */
    public function planSubject()
    {
        return $this->belongsTo(PlanSubject::class, 'plan_subject_id', 'id');
    }

    /**
     * Get the schedule entries (lectures) for this section.
     * علاقة: الشعبة لديها عدة محاضرات في الجدول النهائي (One To Many)
     */
    public function scheduleEntries()
    {
        return $this->hasMany(GeneratedSchedule::class, 'section_id', 'id');
    }

    // يمكنك إضافة علاقات للوصول السريع للمادة والخطة من هنا
    public function subject()
    {
        // للوصول للمادة من خلال علاقة planSubject
        return $this->planSubject->subject(); // قد تحتاج لتحسين الأداء Eager Loading
    }

    public function instructors()
    {
        return $this->belongsToMany(Instructor::class, 'instructor_section');
    }

    public function plan()
    {
        // للوصول للخطة من خلال علاقة planSubject
        return $this->planSubject->plan();
    }
}
----------------------------------------------------------------------------------------------------
app\Models\SelectionType.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SelectionType extends Model
{
    use HasFactory;

    // اسم الجدول في قاعدة البيانات
    // protected $table = 'selection_types';
    protected $primaryKey = 'selection_type_id';

    // الحقول المسموح بتعبئتها
    protected $fillable = ['name', 'slug', 'description', 'is_active'];

    public function populations()
    {
        // علاقة "واحد إلى متعدد" مع جدول populations
        return $this->hasMany(Population::class, 'selection_id', 'selection_type_id');
    }
}
---------------------------------------------------------------------------------------------------------
app\Models\Subject.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Subject extends Model
{
    use HasFactory;

    protected $fillable = [
        'subject_no',
        'subject_name',
        'subject_load',
        'theoretical_hours',
        'practical_hours',
        'subject_type_id',
        'subject_category_id',
        'department_id',
        'load_theoretical_section',
        'load_practical_section',
    ];

    /**
     * Get the type of the subject.
     * علاقة: المادة تتبع لنوع واحد (One To Many Inverse)
     */
    public function subjectType()
    {
        return $this->belongsTo(SubjectType::class, 'subject_type_id', 'id');
    }

    /**
     * Get the category of the subject.
     * علاقة: المادة تتبع لفئة واحدة (One To Many Inverse)
     */
    public function subjectCategory()
    {
        return $this->belongsTo(SubjectCategory::class, 'subject_category_id', 'id');
    }

    /**
     * Get the primary department offering the subject.
     * علاقة: المادة تتبع لقسم واحد (One To Many Inverse)
     */
    public function department()
    {
        return $this->belongsTo(Department::class, 'department_id', 'id');
    }

    /**
     * Get the plans that include this subject.
     * علاقة: المادة موجودة في عدة خطط (Many To Many through plan_subjects)
     */
    public function plans()
    {
        return $this->belongsToMany(Plan::class, 'plan_subjects', 'subject_id', 'plan_id')
            ->withPivot('plan_level', 'plan_semester') // جلب الأعمدة الإضافية من جدول الربط
            ->withTimestamps(); // جلب created_at/updated_at من جدول الربط (إذا احتجت)
    }

    /**
     * Get the plan_subjects entries for this subject.
     * علاقة: المادة لها عدة إدخالات في جدول plan_subjects (One To Many)
     * (مفيدة للوصول المباشر لمعلومات الربط والمستوى والفصل)
     */
    public function planSubjectEntries()
    {
        return $this->hasMany(PlanSubject::class, 'subject_id', 'id');
    }

    public function instructors()
    {
        // اسم الموديل المرتبط، اسم الجدول الوسيط، المفتاح الأجنبي لهذا الموديل، المفتاح الأجنبي للموديل المرتبط
        return $this->belongsToMany(Instructor::class, 'instructor_subject', 'subject_id', 'instructor_id')
            ->withTimestamps(); // إذا أضفت timestamps للجدول الوسيط
    }

    public function requiredRoomType()
{
    // نفترض أن جدول `subjects` يحتوي على حقل `required_room_type_id`
    // الذي هو مفتاح أجنبي لجدول `room_types`.
    return $this->belongsTo(RoomType::class, 'required_room_type_id', 'id');
}



    /**
     * Get the sections for this subject (indirectly through plan_subjects).
     * علاقة: المادة لها شعب كثيرة (One Has Many Through - معقدة قليلاً)
     * أو يمكن الوصول لها عبر planSubjectEntries->sections
     */
    // ...

    /**
     * Get the generated schedule entries for this subject (indirectly).
     * يمكن الوصول لها عبر الشعب Sections
     */
    // ...
}

------------------------------------------------------------------------------------------------------
app\Models\SubjectCategory.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SubjectCategory extends Model
{
    use HasFactory;

    // اسم الجدول مختلف
    protected $table = 'subjects_categories';

    protected $fillable = [
        'subject_category_name',
    ];

    /**
     * Get the subjects in this category.
     * علاقة: الفئة الواحدة لديها عدة مواد (One To Many)
     */
    public function subjects()
    {
        return $this->hasMany(Subject::class, 'subject_category_id', 'id');
    }
}
-------------------------------------------------------------------------------------------------------
app\Models\SubjectType.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class SubjectType extends Model
{
    use HasFactory;

    // اسم الجدول مختلف عن اسم الموديل (subjects_types vs SubjectType)
    protected $table = 'subjects_types'; // حدد اسم الجدول يدوياً

    protected $fillable = [
        'subject_type_name',
    ];

    /**
     * Get the subjects of this type.
     * علاقة: النوع الواحد لديه عدة مواد (One To Many)
     */
    public function subjects()
    {
        return $this->hasMany(Subject::class, 'subject_type_id', 'id');
    }
}
----------------------------------------------------------------------------------------------------------
app\Models\Timeslot.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Timeslot extends Model
{
    use HasFactory;

    protected $fillable = [
        'day',
        'start_time',
        'end_time',
    ];
    // protected $primaryKey = 'timeslot_id';

    // لا تحتاج timestamps إذا لم تضفها في الـ migration
    // public $timestamps = false;

    /**
     * Get the schedule entries (lectures) assigned to this timeslot.
     * علاقة: الفترة الزمنية لديها عدة محاضرات في الجدول النهائي (One To Many)
     */
    public function scheduleEntries()
    {
        return $this->hasMany(GeneratedSchedule::class, 'timeslot_id', 'id');
    }

     /**
     * Accessor to get day name.
     * دالة مساعدة للحصول على اسم اليوم
     */
    public function getDayNameAttribute(): string
    {
        // تأكد من أن الأرقام تبدأ من 0 للأحد
        $days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        return $days[$this->day_of_week] ?? 'Unknown';
    }

    /**
     * Accessor to format start time.
      * دالة مساعدة لتنسيق وقت البداية
     */
    public function getFormattedStartTimeAttribute(): string
    {
        try {
            return \Carbon\Carbon::parse($this->start_time)->format('h:i A');
        } catch (\Exception $e) {
            return $this->start_time; // fallback
        }
    }

     /**
     * Accessor to format end time.
      * دالة مساعدة لتنسيق وقت النهاية
     */
    public function getFormattedEndTimeAttribute(): string
    {
       try {
            return \Carbon\Carbon::parse($this->end_time)->format('h:i A');
        } catch (\Exception $e) {
            return $this->end_time; // fallback
        }
    }

}

-------------------------------------------------------------------------------------------------------
app\Models\User.php
<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

class User extends Authenticatable
{
    use HasApiTokens, HasFactory, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
        'role_id',
        'id'
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
    ];

    /**
     * Get the role associated with the user.
     * علاقة: المستخدم يتبع لدور واحد (One To Many Inverse)
     */
    public function role()
    {
        // اسم الموديل المرتبط، المفتاح الأجنبي في جدول users، المفتاح الأساسي في جدول roles
        return $this->belongsTo(Role::class, 'role_id', 'id');
    }

    /**
     * Get the instructor record associated with the user.
     * علاقة: المستخدم قد يكون له سجل مدرس واحد (One To One)
     */
    public function instructor()
    {
        // اسم الموديل المرتبط، المفتاح الأجنبي في جدول instructors، المفتاح المحلي في جدول users
        return $this->hasOne(Instructor::class, 'user_id', 'id');
    }

    /**
     * Get the logs for the user.
     * علاقة: المستخدم له سجلات كثيرة (One To Many) - إذا لم تستخدم باكج Spatie
     */
    // public function logs()
    // {
    //     return $this->hasMany(Log::class, 'user_id', 'id');
    // }

    /**
     * Get the notifications for the user.
     * علاقة: المستخدم لديه تنبيهات كثيرة (مورف) - هذه تأتي مع Notifiable trait
     */
    // public function notifications() { ... } // تأتي جاهزة

    /**
     * Helper function to check user role by name.
     * دالة مساعدة للتحقق من دور المستخدم بسهولة
     */
    public function hasRole(string|array $roleNames): bool
    {
        if (is_string($roleNames)) {
            return $this->role && $this->role->name === $roleNames;
        }

        return $this->role && in_array($this->role->name, $roleNames);
    }
}
------------------------------------------------------------------------------------------------------
