<?php

namespace App\Services;

use App\Models\Population;
use App\Models\Chromosome;
use App\Models\Gene;
use App\Models\Section;
use App\Models\Instructor;
use App\Models\Room;
use App\Models\Timeslot;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use Exception;

class GeneticAlgorithmService
{
    // الخصائص لتخزين البيانات والإعدادات
    private array $settings;
    private Population $populationRun;
    private Collection $sectionsToSchedule;
    private Collection $instructors;
    private Collection $rooms;
    private Collection $timeslots;
    private Collection $theoryRooms; // **جديد: قاعات نظرية مفلترة**
    private Collection $practicalRooms; // **جديد: قاعات عملية مفلترة**

    /**
     * تهيئة الـ Service
     */
    public function __construct(array $settings, Population $populationRun)
    {
        $this->settings = $settings;
        $this->populationRun = $populationRun;
        Log::info("GA Service initialized for Run ID: {$this->populationRun->population_id}");
    }

    /**
     * الدالة الرئيسية لتشغيل الخوارزمية
     */
    public function run()
    {
        try {
            $this->populationRun->update(['status' => 'running', 'start_time' => now()]);
            // 1. تحميل كل البيانات اللازمة
            $this->loadDataForContext();

            // 2. إنشاء الجيل الأول وتقييمه
            $currentGenerationNumber = 1;
            $currentPopulation = $this->createInitialPopulation($currentGenerationNumber);
            $this->evaluateFitness($currentPopulation);
            Log::info("Generation #{$currentGenerationNumber} fitness evaluated.");

            // 3. حلقة تطور الأجيال
            $maxGenerations = $this->settings['max_generations'];
            while ($currentGenerationNumber < $maxGenerations) {
                // التحقق من شرط التوقف
                $bestInGen = $currentPopulation->sortBy('penalty_value')->first();
                if ($bestInGen && $bestInGen->penalty_value == 0 && ($this->settings['stop_at_first_valid'] ?? false)) {
                    Log::info("Optimal solution found in Generation #{$currentGenerationNumber}. Stopping.");
                    break;
                }

                // اختيار الآباء
                $parents = $this->selectParents($currentPopulation);

                // إنشاء الجيل الجديد
                $currentGenerationNumber++;
                $currentPopulation = $this->createNewGeneration($parents, $currentGenerationNumber);

                // تقييم الجيل الجديد
                $this->evaluateFitness($currentPopulation);
                Log::info("Generation #{$currentGenerationNumber} fitness evaluated.");
            }

            // 4. تحديث النتيجة النهائية
            $finalBest = Chromosome::where('population_id', $this->populationRun->population_id)->orderBy('penalty_value', 'asc')->first();
            $this->populationRun->update([
                'status' => 'completed',
                'end_time' => now(),
                'best_chromosome_id' => $finalBest ? $finalBest->chromosome_id : null
            ]);
            // dd([
            //     'currentPopulation' => $currentPopulation,
            //     'bestInGen' => $bestInGen,
            //     'finalBest' => $finalBest,
            //     '$finalBest->chromosome_id' => $finalBest->chromosome_id,
            // ]);
            Log::info("GA Run ID: {$this->populationRun->population_id} completed.");
        } catch (Exception $e) {
            Log::error("GA Run failed: " . $e->getMessage() . " at " . $e->getFile() . ":" . $e->getLine());
            $this->populationRun->update(['status' => 'failed']);
            throw $e; // Throw exception to fail the job
        }
    }

    /**
     * تحميل البيانات المفلترة بناءً على السياق (سنة وفصل)
     */
    // private function loadDataForContext()
    // {
    //     Log::info("Loading data for context -> Year: {$this->settings['academic_year']}, Semester: {$this->settings['semester']}");

    //     // جلب الشعب المحددة للسياق
    //     $this->sectionsToSchedule = Section::where('academic_year', $this->settings['academic_year'])
    //         ->where('semester', $this->settings['semester'])->get();
    //     if ($this->sectionsToSchedule->isEmpty()) {
    //         throw new Exception("No sections found for the selected context (Year: {$this->settings['academic_year']}, Semester: {$this->settings['semester']}).");
    //     }

    //     // جلب كل الموارد الأخرى المتاحة
    //     $this->instructors = Instructor::all();
    //     $this->rooms = Room::all();
    //     $this->timeslots = Timeslot::all(); // *** نعبئ this->timeslots هنا ***

    //     if ($this->instructors->isEmpty() || $this->rooms->isEmpty() || $this->timeslots->isEmpty()) {
    //         throw new Exception("Missing essential data (instructors, rooms, or timeslots).");
    //     }
    //     Log::info("Data loaded: " . $this->sectionsToSchedule->count() . " sections to be scheduled.");
    // }

    private function loadDataForContext()
    {
        Log::info("Loading data for context -> Year: {$this->settings['academic_year']}, Semester: {$this->settings['semester']}");

        // جلب الشعب وتحميل العلاقات اللازمة لتحديد المدرسين والقاعات
        $this->sectionsToSchedule = Section::with('planSubject.subject.instructors') // *** تحميل المدرسين المرتبطين بالمادة ***
            ->where('academic_year', $this->settings['academic_year'])
            ->where('semester', $this->settings['semester'])->get();

        if ($this->sectionsToSchedule->isEmpty()) {
            throw new Exception("No sections found for the selected context.");
        }

        // جلب كل المدرسين والقاعات والأوقات
        $this->instructors = Instructor::all(); // سنستخدمها كـ fallback
        $this->timeslots = Timeslot::all();
        // **تقسيم القاعات حسب النوع**
        $this->theoryRooms = Room::whereHas('roomType', fn($q) => $q->where('room_type_name', 'not like', '%Lab%')->where('room_type_name', 'not like', '%مختبر%'))->get();
        $this->practicalRooms = Room::whereHas('roomType', fn($q) => $q->where('room_type_name', 'like', '%Lab%')->orWhere('room_type_name', 'like', '%مختبر%'))->get();

        if ($this->instructors->isEmpty() || $this->theoryRooms->isEmpty() || $this->practicalRooms->isEmpty() || $this->timeslots->isEmpty()) {
            throw new Exception("Missing essential data (instructors, theory/practical rooms, or timeslots).");
        }
        Log::info("Data loaded: " . $this->sectionsToSchedule->count() . " sections to be scheduled.");
    }

    private function getRandomInstructorForSection(Section $section)
    {
        // 1. جلب المدرسين المعينين للمادة من خلال جدول instructor_subject
        $suitableInstructors = optional(optional($section->planSubject)->subject)->instructors;

        // 2. إذا وجد مدرسون مناسبون للمادة، اختر واحداً منهم عشوائياً
        if ($suitableInstructors && $suitableInstructors->isNotEmpty()) {
            return $suitableInstructors->random();
        }

        // *** (الخيار المعلق) جلب المدرسين المعينين لهذه الشعبة المحددة من خلال instructor_section ***
        // if ($section->instructors->isNotEmpty()) {
        //     return $section->instructors->random();
        // }


        // 3. كحل بديل (Fallback) إذا لم يتم تعيين مدرسين للمادة، اختر أي مدرس عشوائي
        Log::warning("No specific instructors assigned to subject for section ID: {$section->id}. Choosing a random instructor.");
        return $this->instructors->random();
    }


    /**
     * دالة مساعدة لاختيار قاعة عشوائية ومناسبة للشعبة
     */
    private function getRandomRoomForSection(Section $section)
    {
        // 1. تحديد نوع النشاط للشعبة (نظري أو عملي)
        $activityType = $section->activity_type;

        // 2. إذا كان عملي، اختر من قاعات المختبرات
        if ($activityType === 'Practical' && $this->practicalRooms->isNotEmpty()) {
            // يمكنك إضافة منطق هنا لاختيار مختبر سعته مناسبة للشعبة
            $suitableRooms = $this->practicalRooms->where('room_size', '>=', $section->student_count);
            return $suitableRooms->isNotEmpty() ? $suitableRooms->random() : $this->practicalRooms->random(); // كحل بديل إذا لا توجد قاعة مناسبة
        }

        // 3. إذا كان نظري (أو كـ fallback)، اختر من القاعات النظرية
        if ($this->theoryRooms->isNotEmpty()) {
            $suitableRooms = $this->theoryRooms->where('room_size', '>=', $section->student_count);
            return $suitableRooms->isNotEmpty() ? $suitableRooms->random() : $this->theoryRooms->random();
        }

        // 4. حل بديل أخير إذا لم يتم العثور على أي نوع
        return Room::all()->random();
    }

    /**
     * إنشاء الجيل الأول من الجداول العشوائية
     */
    private function createInitialPopulation(int $generationNumber): Collection
    {
        Log::info("Creating initial population (Generation #{$generationNumber})");
        $newChromosomesData = [];
        // انشاء مجموعة جداول عشوائية Chromosomes
        for ($i = 0; $i < $this->settings['population_size']; $i++) {
            $newChromosomesData[] = [
                'population_id' => $this->populationRun->population_id,
                'penalty_value' => -1, // قيمة مبدئية
                'generation_number' => $generationNumber,
                'created_at' => now(),
                'updated_at' => now(),
            ];
        }
        Chromosome::insert($newChromosomesData); // إدخال كل الكروموسومات دفعة واحدة

        // جلب الكروموسومات التي تم إنشاؤها للتو للحصول على IDs
        $createdChromosomes = Chromosome::where('population_id', $this->populationRun->population_id)
            ->where('generation_number', $generationNumber)->get();

        // foreach ($createdChromosomes as $chromosome) {
        //     foreach ($this->sectionsToSchedule as $section) {
        //         $allGenesToInsert[] = [
        //             'chromosome_id' => $chromosome->chromosome_id,
        //             'section_id' => $section->id,
        //             'instructor_id' => $this->instructors->random()->id,
        //             'room_id' => $this->rooms->random()->id,
        //             'timeslot_id' => $this->timeslots->random()->id, // *** استخدام الطريقة الصحيحة ***
        //         ];
        //     }
        // }
        $allGenesToInsert = [];
        foreach ($createdChromosomes as $chromosome) {
            foreach ($this->sectionsToSchedule as $section) {
                $instructor = $this->getRandomInstructorForSection($section);
                $room = $this->getRandomRoomForSection($section);

                $allGenesToInsert[] = [
                    'chromosome_id' => $chromosome->chromosome_id,
                    'section_id' => $section->id,
                    'instructor_id' => $instructor->id,
                    'room_id' => $room->id,
                    'timeslot_id' => $this->timeslots->random()->id,
                ];
            }
        }

        // إدخال كل الجينات لكل الكروموسومات دفعة واحدة (أكثر كفاءة)
        foreach (array_chunk($allGenesToInsert, 500) as $chunk) {
            Gene::insert($chunk);
        }


        // dd([
        //     'createdChromosomes' => $createdChromosomes,
        //     '$this->timeslots->random()->id' => $this->timeslots->random()->id,
        //     'allGenesToInsert' => $allGenesToInsert,
        //     'array_chunk($allGenesToInsert,500)' => array_chunk($allGenesToInsert,500),
        // ]);
        return $createdChromosomes;
    }

    /**
     * تقييم جودة كل جدول في المجموعة
     */
    private function evaluateFitness(Collection $chromosomes)
    {
        Log::info("Evaluating fitness for " . $chromosomes->count() . " chromosomes...");
        // حساب العقوبات لكل جدول
        foreach ($chromosomes as $chromosome) {
            $genes = $chromosome->genes()->with(['instructor', 'room', 'timeslot', 'section.planSubject.subject'])->get();
            // $genes = $chromosome->genes()->with(['instructor', 'room', 'timeslot', 'section.planSubject.subject', 'section.activity_type'])->get();
            $totalPenalty = 0;
            $genesByTimeslot = $genes->groupBy('timeslot_id');

            // هنستخدم هذا المصفوفة لحساب الساعات اليومية
            $dailyHours = [];

            foreach ($genesByTimeslot as $genesInSlot) {
                if ($genesInSlot->count() > 1) {
                    $totalPenalty += ($genesInSlot->count() - $genesInSlot->pluck('instructor_id')->unique()->count()) * 1000;
                    $totalPenalty += ($genesInSlot->count() - $genesInSlot->pluck('room_id')->unique()->count()) * 1000;
                    $totalPenalty += ($genesInSlot->count() - $genesInSlot->pluck('section_id')->unique()->count()) * 1000;
                }

                // القيود على كل محاضرة في هذا الوقت
                foreach ($genesInSlot as $gene) {
                    $day = $gene->timeslot->day; // اليوم (مثلاً "Monday")

                    // نحسب الساعات اليومية
                    if (!isset($dailyHours[$day])) {
                        $dailyHours[$day] = 0;
                    }
                    $dailyHours[$day] += $gene->timeslot->duration_hours;

                    // سعة القاعة
                    if ($gene->section->students_count > $gene->room->capacity) {
                        $totalPenalty += 800 * ($gene->section->students_count - $gene->room->capacity);
                    }

                    // نوع القاعة
                    if ($gene->section->activity_type != $gene->room->room_type) {
                        $totalPenalty += 600;
                    }

                    // وقت المحاضرة (إجازة)
                    if ($gene->timeslot->is_holiday) {
                        $totalPenalty += 1500;
                    }

                    // أهلية المدرس
                    // if (!$gene->instructor->canTeach($gene->section->subject)) {
                    if (
                        $gene->instructor &&
                        $gene->section &&
                        $gene->section->planSubject &&
                        $gene->section->planSubject->subject &&
                        !$gene->instructor->canTeach($gene->section->planSubject->subject)
                    ) {
                        $totalPenalty += 2000;
                    }
                }
            }

            // القيود على الساعات اليومية
            foreach ($dailyHours as $day => $hours) {
                if ($hours > 10) { // إذا تجاوزت 10 ساعات في اليوم
                    $totalPenalty += 300;
                }
            }
            // ... (باقي حسابات الـ penalty للسعة والنوع) ...
            $chromosome->update(['penalty_value' => $totalPenalty]);
        }
        // dd([
        //     'chromosomes' => $chromosomes,
        //     'genes' => $chromosome->genes->all(),
        //     'genesByTimeslot' => $genesByTimeslot,
        // ]);

        Log::info("Fitness evaluation completed.");
    }

    /**
     * اختيار الآباء (Tournament Selection)
     */
    private function selectParents(Collection $population): array
    {
        $parents = [];
        $populationSize = $this->settings['population_size'];
        $tournamentSize = 3; // يمكن جعله إعداداً
        for ($i = 0; $i < $populationSize; $i++) {
            $parents[] = $population->random($tournamentSize)->sortBy('penalty_value')->first();
        }
        // dd([
        //     'population' => $population,
        //     'parents' => $parents,
        // ]);
        return $parents;
    }

    /**
     * إنشاء جيل جديد بالتزاوج والطفرة
     */
    private function createNewGeneration(array $parents, int $nextGenerationNumber): Collection
    {
        Log::info("Creating new generation #{$nextGenerationNumber}");
        $childrenChromosomesData = [];
        $populationSize = $this->settings['population_size'];
        $parentPool = $parents;

        for ($i = 0; $i < $populationSize; $i += 2) {
            if (count($parentPool) < 2) {
                $parentPool = $parents;
            }
            $p1_key = array_rand($parentPool);
            $parent1 = $parentPool[$p1_key];
            unset($parentPool[$p1_key]);
            $p2_key = array_rand($parentPool);
            $parent2 = $parentPool[$p2_key];
            unset($parentPool[$p2_key]);

            [$child1GenesData, $child2GenesData] = $this->performCrossover($parent1, $parent2);

            $childrenChromosomesData[] = $this->performMutation($child1GenesData);
            if (count($childrenChromosomesData) < $populationSize) {
                $childrenChromosomesData[] = $this->performMutation($child2GenesData);
            }
        }


        $newlyCreatedChromosomes = [];
        foreach ($childrenChromosomesData as $genesToInsert) {
            $newlyCreatedChromosomes[] = $this->saveChildChromosome($genesToInsert, $nextGenerationNumber);
        }
        // dd([
        //     'nextGenerationNumber' => $nextGenerationNumber,
        //     'parents' => $parents,
        //     'parentPool' => $parentPool,
        //     'child1GenesData' => $child1GenesData,
        //     'child2GenesData' => $child2GenesData,
        //     'childrenChromosomesData' => $childrenChromosomesData,
        //     'newlyCreatedChromosomes' => $newlyCreatedChromosomes,
        // ]);
        return collect($newlyCreatedChromosomes);
    }

    /**
     * تنفيذ التزاوج (Single-Point Crossover) - آمن
     */
    private function performCrossover(Chromosome $parent1, Chromosome $parent2): array
    {
        $p1Genes = $parent1->genes()->get()->keyBy('section_id');
        $p2Genes = $parent2->genes()->get()->keyBy('section_id');
        $child1GenesData = [];
        $child2GenesData = [];
        $crossoverPoint = rand(1, $this->sectionsToSchedule->count() - 1);
        $currentIndex = 0;

        foreach ($this->sectionsToSchedule as $section) {
            $sectionId = $section->id;
            $sourceForChild1 = ($currentIndex < $crossoverPoint) ? $p1Genes : $p2Genes;
            $sourceForChild2 = ($currentIndex < $crossoverPoint) ? $p2Genes : $p1Genes;
            $gene1 = $sourceForChild1->get($sectionId) ?? $p2Genes->get($sectionId);
            $gene2 = $sourceForChild2->get($sectionId) ?? $p1Genes->get($sectionId);

            $child1GenesData[] = $gene1 ? $this->extractGeneData($gene1) : $this->createRandomGeneData($sectionId);
            $child2GenesData[] = $gene2 ? $this->extractGeneData($gene2) : $this->createRandomGeneData($sectionId);
            $currentIndex++;
        }
        return [$child1GenesData, $child2GenesData];
    }

    /**
     * تنفيذ الطفرة
     */
    // private function performMutation(array $genes): array
    // {
    //     foreach ($genes as &$geneData) {
    //         if (lcg_value() < $this->settings['mutation_rate']) {
    //             $geneData['timeslot_id'] = $this->timeslots->random()->id; // ** استخدام الطريقة الصحيحة **
    //         }
    //     }
    //     return $genes;
    // }
    private function performMutation(array $genes): array
    {
        foreach ($genes as &$geneData) { // استخدام & لتمرير بالمرجع
            if (lcg_value() < $this->settings['mutation_rate']) {
                Log::info("Mutation on gene for section ID: {$geneData['section_id']}");
                // اختيار عشوائي لما سيتم تغييره (الطفرة)
                $mutationType = rand(1, 3);
                switch ($mutationType) {
                    case 1:
                        // تغيير الفترة الزمنية
                        $geneData['timeslot_id'] = $this->timeslots->random()->id;
                        break;
                    case 2:
                        // تغيير القاعة (مع مراعاة النوع)
                        $section = $this->sectionsToSchedule->find($geneData['section_id']);
                        if ($section) {
                            $geneData['room_id'] = $this->getRandomRoomForSection($section)->id;
                        }
                        break;
                    case 3:
                        // تغيير المدرس (مع مراعاة التخصص)
                        $section = $this->sectionsToSchedule->find($geneData['section_id']);
                        if ($section) {
                            $geneData['instructor_id'] = $this->getRandomInstructorForSection($section)->id;
                        }
                        break;
                }
            }
        }
        return $genes;
    }


    /**
     * دوال مساعدة
     */
    private function saveChildChromosome(array $genes, int $generationNumber): Chromosome
    {
        $chromosome = Chromosome::create(['population_id' => $this->populationRun->population_id, 'penalty_value' => -1, 'generation_number' => $generationNumber]);
        foreach ($genes as &$geneData) {
            $geneData['chromosome_id'] = $chromosome->chromosome_id;
        }
        Gene::insert($genes);
        return $chromosome;
    }
    private function extractGeneData($gene): array
    {
        return ['section_id' => $gene->section_id, 'instructor_id' => $gene->instructor_id, 'room_id' => $gene->room_id, 'timeslot_id' => $gene->timeslot_id];
    }

    private function createRandomGeneData(int $sectionId): array
    {
        $section = $this->sectionsToSchedule->find($sectionId);
        if (!$section) return []; // حالة نادرة

        $instructor = $this->getRandomInstructorForSection($section);
        $room = $this->getRandomRoomForSection($section);

        return [
            'section_id' => $sectionId,
            'instructor_id' => $instructor->id,
            'room_id' => $room->id,
            'timeslot_id' => $this->timeslots->random()->id,
        ];

        // return [
        //     'section_id' => $sectionId,
        //     'instructor_id' => $this->instructors->random()->id,
        //     'room_id' => $this->rooms->random()->id,
        //     'timeslot_id' => $this->timeslots->random()->id, // ** استخدام الطريقة الصحيحة **
        // ];
    }
}
